# V6 - 横切关注点

除了核心功能模块和架构模式，平台V6还特别关注一些贯穿多个模块的横切问题，主要包括统一的异常处理机制和多版本兼容策略。

## 1. 统一异常处理框架

为了规范化异常处理、提高系统的健壮性和可维护性，平台提供了一套统一的异常处理框架。

### 1.1 设计目标

- **规范化**: 定义统一的异常类型和错误码体系。
- **信息丰富**: 异常应携带足够的上下文信息，便于问题定位。
- **易于集成**: 提供简单的集成方式，方便各业务模块使用。
- **灵活处理**: 支持不同的异常处理策略（如记录日志、重试、告警、返回特定错误响应）。
- **避免信息泄露**: 防止敏感信息通过异常堆栈泄露给客户端。
- **可观测性**: 异常信息应能方便地被监控系统捕获和分析。

### 1.2 异常分类与分层

建立清晰的异常继承体系：

```
// 基础运行时异常 (所有自定义非检查异常的基类)
BaseRuntimeException
 | 
 +-- FrameworkException (框架/平台级异常)
 |    +-- ConfigurationException (配置错误)
 |    +-- InfrastructureException (基础设施交互错误，如DB, MQ, Cache)
 |    +-- SecurityException (安全相关异常)
 |    +-- RpcException (远程调用异常)
 | 
 +-- BusinessException (业务逻辑异常，通常可预期)
 |    +-- ValidationException (参数校验失败)
 |    +-- ResourceNotFoundException (资源未找到)
 |    +-- PermissionDeniedException (权限不足)
 |    +-- DuplicatedResourceException (资源重复)
 |    +-- InvalidStateException (状态不合法)
 |    +-- ... (其他具体业务异常)
 | 
 +-- ThirdPartyApiException (第三方API调用异常)
```

- **检查异常 (Checked Exceptions)**: 仅在极其必要时使用（如需强制调用方处理的特定IO或资源问题）。
- **运行时异常 (Unchecked Exceptions)**: 作为主要的异常类型，避免过多的`try-catch`样板代码。

### 1.3 统一错误码

- 定义全局统一的错误码规范，包含错误级别、模块标识、具体错误编号。
- 提供错误码与错误消息的映射配置。
- 异常对象中应包含对应的错误码。

### 1.4 全局异常处理器

- 利用Spring MVC/WebFlux的`@ControllerAdvice`和`@ExceptionHandler`（或类似机制）实现全局异常拦截。
- 根据异常类型，将其转换为统一的API响应格式。
- 记录详细的异常日志（包括堆栈和上下文）。
- 对于未捕获的`FrameworkException`或`RuntimeException`，记录为ERROR级别日志并返回通用服务器错误响应。
- 对于`BusinessException`，通常记录为WARN或INFO级别日志，并返回包含业务错误码和信息的响应。

### 1.5 异常处理策略

框架提供或推荐以下处理策略：

- **日志记录**: 记录详细异常信息。
- **结果包装**: 将异常信息包装在统一的`Result`对象中返回。
- **重试机制**: 对特定的`InfrastructureException`或`ThirdPartyApiException`进行自动重试（如使用Resilience4j）。
- **告警通知**: 对严重的系统异常触发告警。
- **异常收集**: 在批处理或需要持续执行的场景，收集非致命异常，待任务完成后统一处理。

## 2. 多版本兼容策略

为了支持平台的平滑演进和与不同版本组件/客户端的共存，需要制定明确的多版本兼容策略。

### 2.1 Spring Boot/Cloud版本兼容

- **抽象层设计**: 在`platform-framework`中提供抽象接口，隔离具体Spring版本的实现细节。
- **条件化配置**: 使用`@ConditionalOnClass`, `@ConditionalOnProperty`等注解根据环境中的Spring版本加载不同的配置或Bean。
- **启动器模块**: 提供针对不同SpringBoot主版本（如2.x, 3.x）的独立启动器模块(`-boot2x-starter`, `-boot3x-starter`)，处理版本间的API差异。
- **依赖管理**: `platform-dependencies`中可能需要为不同版本定义不同的Profile或BOM。
- **测试覆盖**: 需有覆盖不同Spring版本的兼容性测试。

### 2.2 API版本管理

- **版本策略**: 推荐在URL路径中显式包含主版本号 (e.g., `/api/v1/...`, `/api/v2/...`)。
- **向后兼容**: 
    - 小版本更新（如v1.1 -> v1.2）应保持向后兼容，不破坏现有客户端。
    - 避免删除字段，可标记为`@Deprecated`。
    - 新增可选字段通常是安全的。
    - 修改字段类型或删除枚举值是破坏性变更。
- **演进策略**: 
    - 引入新版本API (v2) 与旧版本 (v1) 并存。
    - 通过API网关或代码内部逻辑引导新客户端使用v2。
    - 监控v1使用情况，在确认无重要客户端使用后，制定v1的废弃计划。
    - 提供清晰的API变更日志和迁移指南。
- **版本协商**: （可选）允许客户端通过`Accept` Header指定期望的版本。

### 2.3 数据模型兼容

- **数据库Schema演进**: 使用数据库迁移工具（如Flyway, Liquibase）管理数据库Schema的变更，确保变更的可追溯性和回滚能力。
- **向前/向后兼容**: 
    - 添加新表、新列（允许NULL或有默认值）通常是安全的。
    - 删除表/列、修改列类型是破坏性变更，需要仔细规划和数据迁移。
    - 考虑使用视图(View)或适配层来兼容旧的数据访问模式。
- **序列化兼容**: 
    - 使用支持版本兼容的序列化格式（如Protobuf，或JSON配合特定配置）。
    - 谨慎修改已有字段名或类型。
    - 为需要持久化的对象（如消息队列中的事件、缓存中的对象）添加版本号。

### 2.4 客户端兼容

- **SDK版本管理**: 如果提供客户端SDK，需遵循语义化版本控制(Semantic Versioning)。
- **特性开关(Feature Flags)**: 使用配置中心或专门的特性开关系统，控制新功能对不同客户端的可见性，实现灰度发布。
- **强制升级与提示**: 对于需要强制升级的客户端版本，提供明确的通知和升级引导。
- **API网关适配**: 网关层可以作为适配器，为旧版本客户端转换API请求/响应格式（应尽量避免，增加复杂性）。 