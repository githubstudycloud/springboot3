# 调度系统设计

## platform-scheduler (调度系统)

**设计目标**：
构建可靠、高性能的分布式任务调度系统，支持复杂的任务依赖关系和执行策略，为平台各模块提供统一的任务调度服务。

**核心功能**：
1. 任务管理：任务创建、配置和管理
2. 调度策略：基于时间、事件、依赖的多种调度方式
3. 任务依赖：支持复杂的任务依赖关系
4. 执行控制：任务暂停、恢复和终止
5. 执行记录：完整的任务执行历史和日志
6. 错误处理：任务失败重试和异常处理
7. 集群协调：分布式环境下的任务协调与负载均衡

**领域模型**：
1. 任务聚合：Task(聚合根)、TaskDependency、TaskConfig、TaskLog
2. 执行器聚合：Executor(聚合根)、ExecutorCapability、ExecutorStatus
3. 调度策略聚合：Schedule(聚合根)、ScheduleRule、ScheduleTime

## 子模块设计

### platform-scheduler-api

**职责**：
- 定义调度系统的接口和契约
- 提供跨模块调用的DTO和命令对象
- 定义事件类型和监听接口

**主要组件**：

1. **DTO对象**
```java
/**
 * 任务DTO
 */
@Data
@Builder
public class TaskDTO {
    private String id;
    private String name;
    private String description;
    private TaskType type;
    private TaskStatus status;
    private TaskConfigDTO config;
    private int priority;
    private String retryStrategy;
    private Integer timeoutMinutes;
    private List<TaskDependencyDTO> dependencies;
    private String createdBy;
    private LocalDateTime createdAt;
    private String updatedBy;
    private LocalDateTime updatedAt;
}

/**
 * 调度策略DTO
 */
@Data
@Builder
public class ScheduleDTO {
    private String id;
    private String taskId;
    private ScheduleType type;
    private String cronExpression;
    private Integer fixedRateSeconds;
    private Integer fixedDelaySeconds;
    private Integer initialDelaySeconds;
    private LocalDateTime oneTimeExecutionTime;
    private String timezone;
    private boolean enabled;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private String createdBy;
    private LocalDateTime createdAt;
    private String updatedBy;
    private LocalDateTime updatedAt;
}

/**
 * 任务执行DTO
 */
@Data
@Builder
public class TaskExecutionDTO {
    private String id;
    private String taskId;
    private String taskName;
    private ExecutionStatus status;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private Long durationMillis;
    private ExecutionResultDTO result;
    private String executedBy;
    private String executorId;
    private List<ExecutionStepDTO> steps;
    private List<String> logs;
}
```

2. **命令对象**
```java
/**
 * 创建任务命令
 */
@Data
@Builder
public class CreateTaskCommand {
    @NotBlank(message = "任务名称不能为空")
    private String name;
    
    private String description;
    
    @NotNull(message = "任务类型不能为空")
    private TaskType type;
    
    @NotNull(message = "任务配置不能为空")
    private TaskConfigDTO config;
    
    @Min(value = 0, message = "优先级不能小于0")
    private int priority;
    
    private String retryStrategy;
    
    private Integer timeoutMinutes;
    
    private List<TaskDependencyDTO> dependencies;
    
    @NotBlank(message = "创建人不能为空")
    private String createdBy;
}

/**
 * 创建调度策略命令
 */
@Data
@Builder
public class CreateScheduleCommand {
    @NotBlank(message = "任务ID不能为空")
    private String taskId;
    
    @NotNull(message = "调度类型不能为空")
    private ScheduleType type;
    
    private String cronExpression;
    
    private Integer fixedRateSeconds;
    
    private Integer fixedDelaySeconds;
    
    private Integer initialDelaySeconds;
    
    private LocalDateTime oneTimeExecutionTime;
    
    private String timezone;
    
    private boolean enabled;
    
    private LocalDateTime startTime;
    
    private LocalDateTime endTime;
    
    @NotBlank(message = "创建人不能为空")
    private String createdBy;
}

/**
 * 执行任务命令
 */
@Data
@Builder
public class ExecuteTaskCommand {
    @NotBlank(message = "任务ID不能为空")
    private String taskId;
    
    private Map<String, Object> parameters;
    
    @NotBlank(message = "执行人不能为空")
    private String executedBy;
}
```

3. **事件定义**
```java
/**
 * 任务创建事件
 */
@Data
public class TaskCreatedEvent implements DomainEvent {
    private final String taskId;
    private final String taskName;
    private final String taskType;
    private final LocalDateTime occurredOn;
    
    public TaskCreatedEvent(String taskId, String taskName, String taskType) {
        this.taskId = taskId;
        this.taskName = taskName;
        this.taskType = taskType;
        this.occurredOn = LocalDateTime.now();
    }
}

/**
 * 任务执行创建事件
 */
@Data
public class TaskExecutionCreatedEvent implements DomainEvent {
    private final String executionId;
    private final String taskId;
    private final LocalDateTime occurredOn;
    
    public TaskExecutionCreatedEvent(String executionId, String taskId) {
        this.executionId = executionId;
        this.taskId = taskId;
        this.occurredOn = LocalDateTime.now();
    }
}

/**
 * 任务执行完成事件
 */
@Data
public class TaskExecutionCompletedEvent implements DomainEvent {
    private final String executionId;
    private final String taskId;
    private final String status;
    private final LocalDateTime occurredOn;
    
    public TaskExecutionCompletedEvent(String executionId, String taskId, String status) {
        this.executionId = executionId;
        this.taskId = taskId;
        this.status = status;
        this.occurredOn = LocalDateTime.now();
    }
}
```

4. **服务接口**
```java
/**
 * 任务服务接口
 */
public interface TaskService {
    /**
     * 创建任务
     * @param command 创建任务命令
     * @return 任务DTO
     */
    TaskDTO createTask(CreateTaskCommand command);
    
    /**
     * 获取任务
     * @param taskId 任务ID
     * @return 任务DTO
     */
    TaskDTO getTaskById(String taskId);
    
    /**
     * 更新任务
     * @param command 更新任务命令
     * @return 任务DTO
     */
    TaskDTO updateTask(UpdateTaskCommand command);
    
    /**
     * 删除任务
     * @param taskId 任务ID
     * @param deletedBy 删除人
     */
    void deleteTask(String taskId, String deletedBy);
    
    /**
     * 激活任务
     * @param taskId 任务ID
     * @param updatedBy 更新人
     * @return 任务DTO
     */
    TaskDTO activateTask(String taskId, String updatedBy);
    
    /**
     * 停用任务
     * @param taskId 任务ID
     * @param updatedBy 更新人
     * @return 任务DTO
     */
    TaskDTO deactivateTask(String taskId, String updatedBy);
    
    /**
     * 获取任务依赖
     * @param taskId 任务ID
     * @return 依赖任务列表
     */
    List<TaskDTO> getTaskDependencies(String taskId);
}

/**
 * 调度服务接口
 */
public interface ScheduleService {
    /**
     * 创建调度策略
     * @param command 创建调度策略命令
     * @return 调度策略DTO
     */
    ScheduleDTO createSchedule(CreateScheduleCommand command);
    
    /**
     * 获取任务的调度策略
     * @param taskId 任务ID
     * @return 调度策略DTO
     */
    ScheduleDTO getScheduleByTaskId(String taskId);
    
    /**
     * 更新调度策略
     * @param command 更新调度策略命令
     * @return 调度策略DTO
     */
    ScheduleDTO updateSchedule(UpdateScheduleCommand command);
    
    /**
     * 启用调度策略
     * @param scheduleId 调度策略ID
     * @param updatedBy 更新人
     * @return 调度策略DTO
     */
    ScheduleDTO enableSchedule(String scheduleId, String updatedBy);
    
    /**
     * 禁用调度策略
     * @param scheduleId 调度策略ID
     * @param updatedBy 更新人
     * @return 调度策略DTO
     */
    ScheduleDTO disableSchedule(String scheduleId, String updatedBy);
    
    /**
     * 获取下一次执行时间
     * @param scheduleId 调度策略ID
     * @return 下一次执行时间
     */
    LocalDateTime getNextExecutionTime(String scheduleId);
}

/**
 * 执行服务接口
 */
public interface ExecutionService {
    /**
     * 执行任务
     * @param command 执行任务命令
     * @return 任务执行DTO
     */
    TaskExecutionDTO executeTask(ExecuteTaskCommand command);
    
    /**
     * 停止任务执行
     * @param executionId 执行ID
     * @param reason 停止原因
     */
    void stopExecution(String executionId, String reason);
    
    /**
     * 获取执行状态
     * @param executionId 执行ID
     * @return 任务执行DTO
     */
    TaskExecutionDTO getExecutionStatus(String executionId);
    
    /**
     * 获取任务的执行历史
     * @param taskId 任务ID
     * @param limit 限制数量
     * @return 任务执行列表
     */
    List<TaskExecutionDTO> getTaskExecutionHistory(String taskId, int limit);
    
    /**
     * 获取执行日志
     * @param executionId 执行ID
     * @return 执行日志
     */
    List<String> getExecutionLogs(String executionId);
}
```

### platform-scheduler-core

**职责**：
- 实现调度系统的核心框架
- 提供调度引擎和执行控制
- 实现任务依赖解析和调度策略

**领域模型实现**：

```java
/**
 * 任务领域模型
 */
@Entity
@Table(name = "sch_task")
public class Task implements AggregateRoot<TaskId> {
    @EmbeddedId
    private TaskId id;
    
    @Column(name = "name", nullable = false)
    private String name;
    
    @Column(name = "description")
    private String description;
    
    @Column(name = "task_type", nullable = false)
    @Enumerated(EnumType.STRING)
    private TaskType type;
    
    @Embedded
    private TaskConfig config;
    
    @Column(name = "status", nullable = false)
    @Enumerated(EnumType.STRING)
    private TaskStatus status;
    
    @Column(name = "priority", nullable = false)
    private int priority;
    
    @Column(name = "retry_strategy", columnDefinition = "TEXT")
    private String retryStrategy; // JSON格式存储重试策略
    
    @Column(name = "timeout_minutes")
    private Integer timeoutMinutes;
    
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;
    
    @Column(name = "created_by", nullable = false)
    private String createdBy;
    
    @Column(name = "updated_by", nullable = false)
    private String updatedBy;
    
    @OneToMany(mappedBy = "taskId", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<TaskDependency> dependencies = new HashSet<>();
    
    protected Task() {}
    
    public Task(TaskId id, String name, TaskType type, TaskConfig config, 
               int priority, String createdBy) {
        this.id = id;
        this.name = name;
        this.type = type;
        this.config = config;
        this.status = TaskStatus.INACTIVE;
        this.priority = priority;
        this.createdAt = LocalDateTime.now();
        this.updatedAt = this.createdAt;
        this.createdBy = createdBy;
        this.updatedBy = createdBy;
    }
    
    public void activate() {
        if (this.status == TaskStatus.INACTIVE) {
            this.status = TaskStatus.ACTIVE;
            this.updatedAt = LocalDateTime.now();
        }
    }
    
    public void deactivate() {
        if (this.status == TaskStatus.ACTIVE) {
            this.status = TaskStatus.INACTIVE;
            this.updatedAt = LocalDateTime.now();
        }
    }
    
    public void addDependency(TaskId dependencyTaskId, DependencyType type) {
        TaskDependency dependency = new TaskDependency(
            this.id, 
            dependencyTaskId, 
            type
        );
        this.dependencies.add(dependency);
        this.updatedAt = LocalDateTime.now();
    }
    
    public void removeDependency(TaskId dependencyTaskId) {
        this.dependencies.removeIf(d -> d.getDependencyTaskId().equals(dependencyTaskId));
        this.updatedAt = LocalDateTime.now();
    }
    
    public boolean canExecute(Set<TaskId> completedTaskIds) {
        return this.dependencies.stream()
            .allMatch(d -> d.isSatisfiedBy(completedTaskIds));
    }
    
    public TaskExecution createExecution(String executedBy) {
        if (this.status != TaskStatus.ACTIVE) {
            throw new TaskInactiveException("Cannot execute inactive task: " + this.id.getValue());
        }
        
        return new TaskExecution(
            TaskExecutionId.generate(),
            this.id,
            this.config,
            ExecutionStatus.PENDING,
            executedBy
        );
    }
    
    @Override
    public TaskId getId() {
        return id;
    }
    
    // Getter methods
}

/**
 * 任务依赖关系
 */
@Entity
@Table(name = "sch_task_dependency")
public class TaskDependency {
    @EmbeddedId
    private TaskDependencyId id;
    
    @Column(name = "task_id", nullable = false)
    private String taskId;
    
    @Column(name = "dependency_task_id", nullable = false)
    private String dependencyTaskId;
    
    @Column(name = "dependency_type", nullable = false)
    @Enumerated(EnumType.STRING)
    private DependencyType type;
    
    protected TaskDependency() {}
    
    public TaskDependency(TaskId taskId, TaskId dependencyTaskId, DependencyType type) {
        this.id = TaskDependencyId.generate();
        this.taskId = taskId.getValue();
        this.dependencyTaskId = dependencyTaskId.getValue();
        this.type = type;
    }
    
    public boolean isSatisfiedBy(Set<TaskId> completedTaskIds) {
        return completedTaskIds.stream()
            .anyMatch(id -> id.getValue().equals(this.dependencyTaskId));
    }
    
    // Getter methods
}

/**
 * 调度策略领域模型
 */
@Entity
@Table(name = "sch_schedule")
public class Schedule implements AggregateRoot<ScheduleId> {
    @EmbeddedId
    private ScheduleId id;
    
    @Column(name = "task_id", nullable = false)
    private String taskId;
    
    @Column(name = "schedule_type", nullable = false)
    @Enumerated(EnumType.STRING)
    private ScheduleType type;
    
    @Column(name = "cron_expression")
    private String cronExpression;
    
    @Column(name = "fixed_rate_seconds")
    private Integer fixedRateSeconds;
    
    @Column(name = "fixed_delay_seconds")
    private Integer fixedDelaySeconds;
    
    @Column(name = "initial_delay_seconds")
    private Integer initialDelaySeconds;
    
    @Column(name = "one_time_execution_time")
    private LocalDateTime oneTimeExecutionTime;
    
    @Column(name = "timezone", nullable = false)
    private String timezone;
    
    @Column(name = "enabled", nullable = false)
    private boolean enabled;
    
    @Column(name = "start_time")
    private LocalDateTime startTime;
    
    @Column(name = "end_time")
    private LocalDateTime endTime;
    
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;
    
    @Column(name = "created_by", nullable = false)
    private String createdBy;
    
    @Column(name = "updated_by", nullable = false)
    private String updatedBy;
    
    protected Schedule() {}
    
    private Schedule(Builder builder) {
        this.id = builder.id;
        this.taskId = builder.taskId;
        this.type = builder.type;
        this.cronExpression = builder.cronExpression;
        this.fixedRateSeconds = builder.fixedRateSeconds;
        this.fixedDelaySeconds = builder.fixedDelaySeconds;
        this.initialDelaySeconds = builder.initialDelaySeconds;
        this.oneTimeExecutionTime = builder.oneTimeExecutionTime;
        this.timezone = builder.timezone;
        this.enabled = builder.enabled;
        this.startTime = builder.startTime;
        this.endTime = builder.endTime;
        this.createdAt = LocalDateTime.now();
        this.updatedAt = this.createdAt;
        this.createdBy = builder.createdBy;
        this.updatedBy = builder.createdBy;
    }
    
    public static class Builder {
        private ScheduleId id;
        private String taskId;
        private ScheduleType type;
        private String cronExpression;
        private Integer fixedRateSeconds;
        private Integer fixedDelaySeconds;
        private Integer initialDelaySeconds;
        private LocalDateTime oneTimeExecutionTime;
        private String timezone = "UTC";
        private boolean enabled = false;
        private LocalDateTime startTime;
        private LocalDateTime endTime;
        private String createdBy;
        
        public Builder(String taskId, ScheduleType type, String createdBy) {
            this.id = ScheduleId.generate();
            this.taskId = taskId;
            this.type = type;
            this.createdBy = createdBy;
        }
        
        public Builder cronExpression(String cronExpression) {
            this.cronExpression = cronExpression;
            return this;
        }
        
        public Builder fixedRate(int seconds) {
            this.fixedRateSeconds = seconds;
            return this;
        }
        
        public Builder fixedDelay(int seconds) {
            this.fixedDelaySeconds = seconds;
            return this;
        }
        
        public Builder initialDelay(int seconds) {
            this.initialDelaySeconds = seconds;
            return this;
        }
        
        public Builder oneTimeExecution(LocalDateTime time) {
            this.oneTimeExecutionTime = time;
            return this;
        }
        
        public Builder timezone(String timezone) {
            this.timezone = timezone;
            return this;
        }
        
        public Builder enabled(boolean enabled) {
            this.enabled = enabled;
            return this;
        }
        
        public Builder startTime(LocalDateTime startTime) {
            this.startTime = startTime;
            return this;
        }
        
        public Builder endTime(LocalDateTime endTime) {
            this.endTime = endTime;
            return this;
        }
        
        public Schedule build() {
            validate();
            return new Schedule(this);
        }
        
        private void validate() {
            switch (type) {
                case CRON:
                    if (cronExpression == null || cronExpression.isEmpty()) {
                        throw new IllegalArgumentException("Cron expression is required for CRON schedule type");
                    }
                    break;
                case FIXED_RATE:
                    if (fixedRateSeconds == null || fixedRateSeconds <= 0) {
                        throw new IllegalArgumentException("Fixed rate seconds is required and must be positive");
                    }
                    break;
                case FIXED_DELAY:
                    if (fixedDelaySeconds == null || fixedDelaySeconds <= 0) {
                        throw new IllegalArgumentException("Fixed delay seconds is required and must be positive");
                    }
                    break;
                case ONE_TIME:
                    if (oneTimeExecutionTime == null) {
                        throw new IllegalArgumentException("Execution time is required for ONE_TIME schedule type");
                    }
                    break;
                default:
                    throw new IllegalArgumentException("Unsupported schedule type: " + type);
            }
        }
    }
    
    public void enable() {
        this.enabled = true;
        this.updatedAt = LocalDateTime.now();
    }
    
    public void disable() {
        this.enabled = false;
        this.updatedAt = LocalDateTime.now();
    }
    
    public LocalDateTime getNextExecutionTime(LocalDateTime lastExecutionTime) {
        if (!this.enabled) {
            return null;
        }
        
        if (this.endTime != null && LocalDateTime.now().isAfter(this.endTime)) {
            return null;
        }
        
        switch (this.type) {
            case CRON:
                return calculateNextCronTime(lastExecutionTime);
            case FIXED_RATE:
                return lastExecutionTime.plusSeconds(this.fixedRateSeconds);
            case FIXED_DELAY:
                return LocalDateTime.now().plusSeconds(this.fixedDelaySeconds);
            case ONE_TIME:
                return (lastExecutionTime == null) ? this.oneTimeExecutionTime : null;
            default:
                return null;
        }
    }
    
    private LocalDateTime calculateNextCronTime(LocalDateTime lastExecutionTime) {
        // 实现基于cron表达式的下次执行时间计算
        // 这里简化处理，实际实现可能需要使用Quartz等库
        return LocalDateTime.now().plusHours(1);
    }
    
    @Override
    public ScheduleId getId() {
        return id;
    }
    
    // Getter methods
}
```

**调度引擎设计**：

```java
/**
 * 调度引擎接口
 */
public interface ScheduleEngine {
    /**
     * 启动调度引擎
     */
    void start();
    
    /**
     * 停止调度引擎
     */
    void stop();
    
    /**
     * 注册调度
     * @param schedule 调度策略
     */
    void registerSchedule(Schedule schedule);
    
    /**
     * 更新调度
     * @param schedule 调度策略
     */
    void updateSchedule(Schedule schedule);
    
    /**
     * 取消调度
     * @param scheduleId 调度ID
     */
    void unregisterSchedule(ScheduleId scheduleId);
    
    /**
     * 暂停调度
     * @param scheduleId 调度ID
     */
    void pauseSchedule(ScheduleId scheduleId);
    
    /**
     * 恢复调度
     * @param scheduleId 调度ID
     */
    void resumeSchedule(ScheduleId scheduleId);
    
    /**
     * 获取下一次执行时间
     * @param scheduleId 调度ID
     * @return 下一次执行时间
     */
    LocalDateTime getNextExecutionTime(ScheduleId scheduleId);
}

/**
 * Quartz调度引擎实现
 */
@Component
public class QuartzScheduleEngine implements ScheduleEngine {
    private static final Logger logger = LoggerFactory.getLogger(QuartzScheduleEngine.class);
    
    private final Scheduler scheduler;
    private final ExecutionService executionService;
    private final TaskRepository taskRepository;
    
    @PostConstruct
    public void init() throws SchedulerException {
        // 初始化调度器
        scheduler.start();
        
        // 加载所有启用的调度策略
        List<Schedule> activeSchedules = scheduleRepository.findByEnabled(true);
        for (Schedule schedule : activeSchedules) {
            registerSchedule(schedule);
        }
    }
    
    @PreDestroy
    public void destroy() throws SchedulerException {
        scheduler.shutdown();
    }
    
    @Override
    public void start() {
        try {
            if (scheduler.isShutdown()) {
                scheduler.start();
            }
        } catch (SchedulerException e) {
            logger.error("Failed to start scheduler", e);
            throw new SchedulerStartException("Failed to start scheduler", e);
        }
    }
    
    @Override
    public void stop() {
        try {
            if (!scheduler.isShutdown()) {
                scheduler.standby();
            }
        } catch (SchedulerException e) {
            logger.error("Failed to stop scheduler", e);
            throw new SchedulerStopException("Failed to stop scheduler", e);
        }
    }
    
    @Override
    public void registerSchedule(Schedule schedule) {
        if (!schedule.isEnabled()) {
            logger.debug("Schedule {} is disabled, skipping registration", schedule.getId().getValue());
            return;
        }
        
        try {
            JobDetail jobDetail = createJobDetail(schedule);
            Trigger trigger = createTrigger(schedule);
            
            if (scheduler.checkExists(jobDetail.getKey())) {
                scheduler.deleteJob(jobDetail.getKey());
            }
            
            scheduler.scheduleJob(jobDetail, trigger);
            logger.info("Registered schedule: {}", schedule.getId().getValue());
            
        } catch (SchedulerException e) {
            logger.error("Failed to register schedule: {}", schedule.getId().getValue(), e);
            throw new ScheduleRegistrationException("Failed to register schedule", e);
        }
    }
    
    @Override
    public void updateSchedule(Schedule schedule) {
        // 先取消再注册
        try {
            unregisterSchedule(schedule.getId());
            registerSchedule(schedule);
            
        } catch (Exception e) {
            logger.error("Failed to update schedule: {}", schedule.getId().getValue(), e);
            throw new ScheduleUpdateException("Failed to update schedule", e);
        }
    }
    
    @Override
    public void unregisterSchedule(ScheduleId scheduleId) {
        try {
            JobKey jobKey = createJobKey(scheduleId);
            
            if (scheduler.checkExists(jobKey)) {
                scheduler.deleteJob(jobKey);
                logger.info("Unregistered schedule: {}", scheduleId.getValue());
            } else {
                logger.warn("Schedule not found for unregistration: {}", scheduleId.getValue());
            }
            
        } catch (SchedulerException e) {
            logger.error("Failed to unregister schedule: {}", scheduleId.getValue(), e);
            throw new ScheduleUnregistrationException("Failed to unregister schedule", e);
        }
    }
    
    @Override
    public void pauseSchedule(ScheduleId scheduleId) {
        try {
            JobKey jobKey = createJobKey(scheduleId);
            
            if (scheduler.checkExists(jobKey)) {
                scheduler.pauseJob(jobKey);
                logger.info("Paused schedule: {}", scheduleId.getValue());
            } else {
                logger.warn("Schedule not found for pause: {}", scheduleId.getValue());
            }
            
        } catch (SchedulerException e) {
            logger.error("Failed to pause schedule: {}", scheduleId.getValue(), e);
            throw new SchedulePauseException("Failed to pause schedule", e);
        }
    }
    
    @Override
    public void resumeSchedule(ScheduleId scheduleId) {
        try {
            JobKey jobKey = createJobKey(scheduleId);
            
            if (scheduler.checkExists(jobKey)) {
                scheduler.resumeJob(jobKey);
                logger.info("Resumed schedule: {}", scheduleId.getValue());
            } else {
                logger.warn("Schedule not found for resume: {}", scheduleId.getValue());
            }
            
        } catch (SchedulerException e) {
            logger.error("Failed to resume schedule: {}", scheduleId.getValue(), e);
            throw new ScheduleResumeException("Failed to resume schedule", e);
        }
    }
    
    @Override
    public LocalDateTime getNextExecutionTime(ScheduleId scheduleId) {
        try {
            JobKey jobKey = createJobKey(scheduleId);
            
            if (!scheduler.checkExists(jobKey)) {
                return null;
            }
            
            List<? extends Trigger> triggers = scheduler.getTriggersOfJob(jobKey);
            if (triggers.isEmpty()) {
                return null;
            }
            
            Date nextFireTime = triggers.get(0).getNextFireTime();
            return nextFireTime != null 
                ? LocalDateTime.ofInstant(nextFireTime.toInstant(), ZoneId.systemDefault())
                : null;
                
        } catch (SchedulerException e) {
            logger.error("Failed to get next execution time for schedule: {}", scheduleId.getValue(), e);
            throw new ScheduleOperationException("Failed to get next execution time", e);
        }
    }
    
    private JobDetail createJobDetail(Schedule schedule) {
        // 获取任务ID
        String taskId = schedule.getTaskId();
        
        // 创建Job数据
        JobDataMap jobDataMap = new JobDataMap();
        jobDataMap.put("taskId", taskId);
        jobDataMap.put("scheduleId", schedule.getId().getValue());
        
        // 创建JobDetail
        return JobBuilder.newJob(TaskExecutionJob.class)
            .withIdentity(createJobKey(schedule.getId()))
            .withDescription("Schedule for task: " + taskId)
            .usingJobData(jobDataMap)
            .storeDurably()
            .build();
    }
    
    private Trigger createTrigger(Schedule schedule) {
        TriggerBuilder<Trigger> triggerBuilder = TriggerBuilder.newTrigger()
            .withIdentity("trigger-" + schedule.getId().getValue())
            .forJob(createJobKey(schedule.getId()))
            .withDescription("Trigger for schedule: " + schedule.getId().getValue());
        
        // 设置开始时间
        if (schedule.getStartTime() != null) {
            triggerBuilder.startAt(Date.from(schedule.getStartTime().atZone(ZoneId.systemDefault()).toInstant()));
        } else {
            triggerBuilder.startNow();
        }
        
        // 设置结束时间
        if (schedule.getEndTime() != null) {
            triggerBuilder.endAt(Date.from(schedule.getEndTime().atZone(ZoneId.systemDefault()).toInstant()));
        }
        
        // 根据调度类型设置触发器
        switch (schedule.getType()) {
            case CRON:
                return triggerBuilder.withSchedule(
                    CronScheduleBuilder.cronSchedule(schedule.getCronExpression())
                        .inTimeZone(TimeZone.getTimeZone(schedule.getTimezone()))
                ).build();
                
            case FIXED_RATE:
                return triggerBuilder.withSchedule(
                    SimpleScheduleBuilder.simpleSchedule()
                        .withIntervalInSeconds(schedule.getFixedRateSeconds())
                        .repeatForever()
                ).build();
                
            case FIXED_DELAY:
                // Quartz不直接支持fixedDelay，需要在Job执行完成后再调度
                return triggerBuilder.withSchedule(
                    SimpleScheduleBuilder.simpleSchedule()
                        .withIntervalInSeconds(schedule.getFixedDelaySeconds())
                        .repeatForever()
                ).build();
                
            case ONE_TIME:
                return triggerBuilder
                    .startAt(Date.from(schedule.getOneTimeExecutionTime().atZone(ZoneId.systemDefault()).toInstant()))
                    .build();
                
            default:
                throw new IllegalArgumentException("Unsupported schedule type: " + schedule.getType());
        }
    }
    
    private JobKey createJobKey(ScheduleId scheduleId) {
        return JobKey.jobKey("job-" + scheduleId.getValue());
    }
}

/**
 * 任务执行Job
 */
public class TaskExecutionJob implements Job {
    private static final Logger logger = LoggerFactory.getLogger(TaskExecutionJob.class);
    
    @Autowired
    private TaskRepository taskRepository;
    
    @Autowired
    private ExecutionService executionService;
    
    @Override
    public void execute(JobExecutionContext context) throws JobExecutionException {
        JobDataMap dataMap = context.getMergedJobDataMap();
        String taskId = dataMap.getString("taskId");
        String scheduleId = dataMap.getString("scheduleId");
        
        logger.info("Executing scheduled task: {}, schedule: {}", taskId, scheduleId);
        
        try {
            // 查找任务
            Task task = taskRepository.findById(TaskId.of(taskId))
                .orElseThrow(() -> new TaskNotFoundException("Task not found: " + taskId));
            
            // 检查任务状态
            if (task.getStatus() != TaskStatus.ACTIVE) {
                logger.warn("Task is not active, skipping execution: {}", taskId);
                return;
            }
            
            // 执行任务
            ExecuteTaskCommand command = ExecuteTaskCommand.builder()
                .taskId(taskId)
                .executedBy("scheduler") // 系统执行
                .build();
            
            TaskExecutionDTO execution = executionService.executeTask(command);
            logger.info("Task execution created: {}", execution.getId());
            
        } catch (Exception e) {
            logger.error("Failed to execute scheduled task: {}", taskId, e);
            throw new JobExecutionException("Failed to execute scheduled task", e);
        }
    }
}
```

**应用服务实现**：

```java
/**
 * 任务应用服务
 */
@Service
@Transactional
public class TaskApplicationService implements TaskService {
    private final TaskRepository taskRepository;
    private final ScheduleRepository scheduleRepository;
    private final TaskExecutionRepository executionRepository;
    private final DomainEventPublisher eventPublisher;
    
    public TaskApplicationService(TaskRepository taskRepository,
                                 ScheduleRepository scheduleRepository,
                                 TaskExecutionRepository executionRepository,
                                 DomainEventPublisher eventPublisher) {
        this.taskRepository = taskRepository;
        this.scheduleRepository = scheduleRepository;
        this.executionRepository = executionRepository;
        this.eventPublisher = eventPublisher;
    }
    
    @Override
    public TaskDTO createTask(CreateTaskCommand command) {
        // 检查任务名称是否已存在
        if (taskRepository.existsByName(command.getName())) {
            throw new TaskNameDuplicateException(command.getName());
        }
        
        // 创建任务
        Task task = new Task(
            TaskId.generate(),
            command.getName(),
            command.getType(),
            TaskConfig.fromDto(command.getConfig()),
            command.getPriority(),
            command.getCreatedBy()
        );
        
        // 设置描述
        task.setDescription(command.getDescription());
        
        // 设置超时时间
        if (command.getTimeoutMinutes() != null) {
            task.setTimeout(command.getTimeoutMinutes());
        }
        
        // 设置重试策略
        if (command.getRetryStrategy() != null) {
            task.setRetryStrategy(command.getRetryStrategy());
        }
        
        // 添加依赖
        if (command.getDependencies() != null) {
            for (TaskDependencyDTO dependency : command.getDependencies()) {
                task.addDependency(
                    TaskId.of(dependency.getDependencyTaskId()),
                    dependency.getType()
                );
            }
        }
        
        // 保存任务
        taskRepository.save(task);
        
        // 发布领域事件
        eventPublisher.publish(new TaskCreatedEvent(
            task.getId().getValue(),
            task.getName(),
            task.getType().name()
        ));
        
        // 返回DTO
        return TaskDTOAssembler.toDTO(task);
    }
    
    @Override
    public TaskDTO getTaskById(String taskId) {
        Task task = findTaskById(taskId);
        return TaskDTOAssembler.toDTO(task);
    }
    
    @Override
    public TaskDTO updateTask(UpdateTaskCommand command) {
        // 获取任务
        Task task = findTaskById(command.getTaskId());
        
        // 更新名称
        if (command.getName() != null && !command.getName().equals(task.getName())) {
            // 检查名称唯一性
            if (taskRepository.existsByName(command.getName())) {
                throw new TaskNameDuplicateException(command.getName());
            }
            task.setName(command.getName());
        }
        
        // 更新描述
        if (command.getDescription() != null) {
            task.setDescription(command.getDescription());
        }
        
        // 更新配置
        if (command.getConfig() != null) {
            task.setConfig(TaskConfig.fromDto(command.getConfig()));
        }
        
        // 更新优先级
        if (command.getPriority() != null) {
            task.setPriority(command.getPriority());
        }
        
        // 更新超时时间
        if (command.getTimeoutMinutes() != null) {
            task.setTimeout(command.getTimeoutMinutes());
        }
        
        // 更新重试策略
        if (command.getRetryStrategy() != null) {
            task.setRetryStrategy(command.getRetryStrategy());
        }
        
        // 更新依赖
        if (command.getDependencies() != null) {
            // 清除现有依赖
            task.clearDependencies();
            
            // 添加新依赖
            for (TaskDependencyDTO dependency : command.getDependencies()) {
                task.addDependency(
                    TaskId.of(dependency.getDependencyTaskId()),
                    dependency.getType()
                );
            }
        }
        
        // 设置更新人
        task.setUpdatedBy(command.getUpdatedBy());
        
        // 保存任务
        taskRepository.save(task);
        
        // 发布领域事件
        eventPublisher.publish(new TaskUpdatedEvent(
            task.getId().getValue(),
            task.getName()
        ));
        
        // 返回DTO
        return TaskDTOAssembler.toDTO(task);
    }
    
    @Override
    public void deleteTask(String taskId, String deletedBy) {
        // 获取任务
        Task task = findTaskById(taskId);
        
        // 删除任务相关的调度策略
        scheduleRepository.findByTaskId(taskId)
            .ifPresent(schedule -> scheduleRepository.delete(schedule));
        
        // 删除任务
        taskRepository.delete(task);
        
        // 发布领域事件
        eventPublisher.publish(new TaskDeletedEvent(
            taskId,
            task.getName(),
            deletedBy
        ));
    }
    
    @Override
    public TaskDTO activateTask(String taskId, String updatedBy) {
        // 获取任务
        Task task = findTaskById(taskId);
        
        // 激活任务
        task.activate();
        task.setUpdatedBy(updatedBy);
        
        // 保存任务
        taskRepository.save(task);
        
        // 发布领域事件
        eventPublisher.publish(new TaskActivatedEvent(
            task.getId().getValue(),
            task.getName()
        ));
        
        // 返回DTO
        return TaskDTOAssembler.toDTO(task);
    }
    
    @Override
    public TaskDTO deactivateTask(String taskId, String updatedBy) {
        // 获取任务
        Task task = findTaskById(taskId);
        
        // 停用任务
        task.deactivate();
        task.setUpdatedBy(updatedBy);
        
        // 保存任务
        taskRepository.save(task);
        
        // 发布领域事件
        eventPublisher.publish(new TaskDeactivatedEvent(
            task.getId().getValue(),
            task.getName()
        ));
        
        // 返回DTO
        return TaskDTOAssembler.toDTO(task);
    }
    
    @Override
    public List<TaskDTO> getTaskDependencies(String taskId) {
        // 获取任务
        Task task = findTaskById(taskId);
        
        // 获取依赖的任务ID
        List<String> dependencyIds = task.getDependencies().stream()
            .map(TaskDependency::getDependencyTaskId)
            .collect(Collectors.toList());
        
        // 查询依赖的任务
        List<Task> dependencies = taskRepository.findAllById(
            dependencyIds.stream()
                .map(TaskId::of)
                .collect(Collectors.toList())
        );
        
        // 转换为DTO
        return dependencies.stream()
            .map(TaskDTOAssembler::toDTO)
            .collect(Collectors.toList());
    }
    
    private Task findTaskById(String taskId) {
        return taskRepository.findById(TaskId.of(taskId))
            .orElseThrow(() -> new TaskNotFoundException("Task not found: " + taskId));
    }
}

/**
 * 调度应用服务
 */
@Service
@Transactional
public class ScheduleApplicationService implements ScheduleService {
    private final ScheduleRepository scheduleRepository;
    private final TaskRepository taskRepository;
    private final ScheduleEngine scheduleEngine;
    private final DomainEventPublisher eventPublisher;
    
    @Override
    public ScheduleDTO createSchedule(CreateScheduleCommand command) {
        // 检查任务是否存在
        if (!taskRepository.existsById(TaskId.of(command.getTaskId()))) {
            throw new TaskNotFoundException("Task not found: " + command.getTaskId());
        }
        
        // 检查是否已有调度策略
        if (scheduleRepository.findByTaskId(command.getTaskId()).isPresent()) {
            throw new ScheduleAlreadyExistsException("Schedule already exists for task: " + command.getTaskId());
        }
        
        // 创建调度策略构建器
        Schedule.Builder builder = new Schedule.Builder(
            command.getTaskId(),
            command.getType(),
            command.getCreatedBy()
        );
        
        // 设置调度属性
        switch (command.getType()) {
            case CRON:
                builder.cronExpression(command.getCronExpression());
                break;
                
            case FIXED_RATE:
                builder.fixedRate(command.getFixedRateSeconds());
                break;
                
            case FIXED_DELAY:
                builder.fixedDelay(command.getFixedDelaySeconds());
                break;
                
            case ONE_TIME:
                builder.oneTimeExecution(command.getOneTimeExecutionTime());
                break;
        }
        
        // 设置其他属性
        builder.timezone(command.getTimezone());
        builder.enabled(command.isEnabled());
        builder.startTime(command.getStartTime());
        builder.endTime(command.getEndTime());
        
        // 创建调度策略
        Schedule schedule = builder.build();
        
        // 保存调度策略
        scheduleRepository.save(schedule);
        
        // 注册到调度引擎
        if (schedule.isEnabled()) {
            scheduleEngine.registerSchedule(schedule);
        }
        
        // 发布领域事件
        eventPublisher.publish(new ScheduleCreatedEvent(
            schedule.getId().getValue(),
            schedule.getTaskId(),
            schedule.getType().name()
        ));
        
        // 返回DTO
        return ScheduleDTOAssembler.toDTO(schedule);
    }
    
    @Override
    public ScheduleDTO getScheduleByTaskId(String taskId) {
        Schedule schedule = scheduleRepository.findByTaskId(taskId)
            .orElseThrow(() -> new ScheduleNotFoundException("Schedule not found for task: " + taskId));
            
        return ScheduleDTOAssembler.toDTO(schedule);
    }
    
    @Override
    public ScheduleDTO updateSchedule(UpdateScheduleCommand command) {
        // 获取调度策略
        Schedule schedule = scheduleRepository.findById(ScheduleId.of(command.getScheduleId()))
            .orElseThrow(() -> new ScheduleNotFoundException("Schedule not found: " + command.getScheduleId()));
        
        // 创建新的调度策略（不可变对象模式）
        Schedule.Builder builder = new Schedule.Builder(
            schedule.getTaskId(),
            command.getType() != null ? command.getType() : schedule.getType(),
            command.getUpdatedBy()
        );
        
        // 设置调度属性
        switch (builder.getType()) {
            case CRON:
                builder.cronExpression(command.getCronExpression() != null ? 
                    command.getCronExpression() : schedule.getCronExpression());
                break;
                
            case FIXED_RATE:
                builder.fixedRate(command.getFixedRateSeconds() != null ? 
                    command.getFixedRateSeconds() : schedule.getFixedRateSeconds());
                break;
                
            case FIXED_DELAY:
                builder.fixedDelay(command.getFixedDelaySeconds() != null ? 
                    command.getFixedDelaySeconds() : schedule.getFixedDelaySeconds());
                break;
                
            case ONE_TIME:
                builder.oneTimeExecution(command.getOneTimeExecutionTime() != null ? 
                    command.getOneTimeExecutionTime() : schedule.getOneTimeExecutionTime());
                break;
        }
        
        // 设置其他属性
        builder.timezone(command.getTimezone() != null ? command.getTimezone() : schedule.getTimezone());
        builder.enabled(command.getEnabled() != null ? command.getEnabled() : schedule.isEnabled());
        builder.startTime(command.getStartTime() != null ? command.getStartTime() : schedule.getStartTime());
        builder.endTime(command.getEndTime() != null ? command.getEndTime() : schedule.getEndTime());
        
        // 创建新调度策略
        Schedule newSchedule = builder.build();
        newSchedule.setId(schedule.getId()); // 保持ID不变
        
        // 保存调度策略
        scheduleRepository.save(newSchedule);
        
        // 更新调度引擎
        scheduleEngine.updateSchedule(newSchedule);
        
        // 发布领域事件
        eventPublisher.publish(new ScheduleUpdatedEvent(
            newSchedule.getId().getValue(),
            newSchedule.getTaskId()
        ));
        
        // 返回DTO
        return ScheduleDTOAssembler.toDTO(newSchedule);
    }
    
    @Override
    public ScheduleDTO enableSchedule(String scheduleId, String updatedBy) {
        // 获取调度策略
        Schedule schedule = scheduleRepository.findById(ScheduleId.of(scheduleId))
            .orElseThrow(() -> new ScheduleNotFoundException("Schedule not found: " + scheduleId));
        
        // 激活调度策略
        schedule.enable();
        schedule.setUpdatedBy(updatedBy);
        
        // 保存调度策略
        scheduleRepository.save(schedule);
        
        // 恢复调度引擎中的调度
        scheduleEngine.resumeSchedule(schedule.getId());
        
        // 发布领域事件
        eventPublisher.publish(new ScheduleEnabledEvent(
            schedule.getId().getValue(),
            schedule.getTaskId()
        ));
        
        // 返回DTO
        return ScheduleDTOAssembler.toDTO(schedule);
    }
    
    @Override
    public ScheduleDTO disableSchedule(String scheduleId, String updatedBy) {
        // 获取调度策略
        Schedule schedule = scheduleRepository.findById(ScheduleId.of(scheduleId))
            .orElseThrow(() -> new ScheduleNotFoundException("Schedule not found: " + scheduleId));
        
        // 停用调度策略
        schedule.disable();
        schedule.setUpdatedBy(updatedBy);
        
        // 保存调度策略
        scheduleRepository.save(schedule);
        
        // 暂停调度引擎中的调度
        scheduleEngine.pauseSchedule(schedule.getId());
        
        // 发布领域事件
        eventPublisher.publish(new ScheduleDisabledEvent(
            schedule.getId().getValue(),
            schedule.getTaskId()
        ));
        
        // 返回DTO
        return ScheduleDTOAssembler.toDTO(schedule);
    }
    
    @Override
    public LocalDateTime getNextExecutionTime(String scheduleId) {
        // 获取调度策略
        Schedule schedule = scheduleRepository.findById(ScheduleId.of(scheduleId))
            .orElseThrow(() -> new ScheduleNotFoundException("Schedule not found: " + scheduleId));
        
        // 如果调度策略未启用，返回null
        if (!schedule.isEnabled()) {
            return null;
        }
        
        // 从调度引擎获取下一次执行时间
        return scheduleEngine.getNextExecutionTime(schedule.getId());
    }
}

/**
 * 执行应用服务
 */
@Service
@Transactional
public class ExecutionApplicationService implements ExecutionService {
    private final TaskRepository taskRepository;
    private final TaskExecutionRepository executionRepository;
    private final ExecutionEngine executionEngine;
    private final DomainEventPublisher eventPublisher;
    
    @Override
    public TaskExecutionDTO executeTask(ExecuteTaskCommand command) {
        // 获取任务
        Task task = taskRepository.findById(TaskId.of(command.getTaskId()))
            .orElseThrow(() -> new TaskNotFoundException("Task not found: " + command.getTaskId()));
        
        // 创建执行记录
        TaskExecution execution = task.createExecution(command.getExecutedBy());
        
        // 设置执行参数
        if (command.getParameters() != null) {
            execution.setParameters(command.getParameters());
        }
        
        // 保存执行记录
        executionRepository.save(execution);
        
        // 发布领域事件
        eventPublisher.publish(new TaskExecutionCreatedEvent(
            execution.getId().getValue(),
            task.getId().getValue()
        ));
        
        // 异步执行任务
        taskExecutor.execute(() -> {
            try {
                executionEngine.execute(task, execution);
            } catch (Exception e) {
                // 记录异常
                logger.error("Failed to execute task: {}", task.getId().getValue(), e);
                
                // 更新执行状态
                execution.fail(e.getMessage());
                executionRepository.save(execution);
                
                // 发布执行失败事件
                eventPublisher.publish(new TaskExecutionFailedEvent(
                    execution.getId().getValue(),
                    task.getId().getValue(),
                    e.getMessage()
                ));
            }
        });
        
        // 返回执行DTO
        return TaskExecutionDTOAssembler.toDTO(execution);
    }
    
    @Override
    public void stopExecution(String executionId, String reason) {
        // 获取执行记录
        TaskExecution execution = executionRepository.findById(TaskExecutionId.of(executionId))
            .orElseThrow(() -> new ExecutionNotFoundException("Execution not found: " + executionId));
        
        // 检查是否可以停止
        if (!execution.canStop()) {
            throw new IllegalStateException("Cannot stop execution in state: " + execution.getStatus());
        }
        
        // 停止执行
        executionEngine.stopExecution(execution.getId());
        
        // 更新执行状态
        execution.stop(reason);
        executionRepository.save(execution);
        
        // 发布执行停止事件
        eventPublisher.publish(new TaskExecutionStoppedEvent(
            execution.getId().getValue(),
            execution.getTaskId(),
            reason
        ));
    }
    
    @Override
    public TaskExecutionDTO getExecutionStatus(String executionId) {
        // 获取执行记录
        TaskExecution execution = executionRepository.findById(TaskExecutionId.of(executionId))
            .orElseThrow(() -> new ExecutionNotFoundException("Execution not found: " + executionId));
        
        // 如果执行正在进行中，从执行引擎获取最新状态
        if (execution.isRunning()) {
            ExecutionStatus currentStatus = executionEngine.getExecutionStatus(execution.getId());
            
            // 如果状态已变更，更新执行记录
            if (currentStatus != execution.getStatus()) {
                execution.updateStatus(currentStatus);
                executionRepository.save(execution);
            }
        }
        
        // 返回执行DTO
        return TaskExecutionDTOAssembler.toDTO(execution);
    }
    
    @Override
    public List<TaskExecutionDTO> getTaskExecutionHistory(String taskId, int limit) {
        // 获取任务执行历史
        List<TaskExecution> executions = executionRepository.findByTaskIdOrderByStartTimeDesc(
            taskId, 
            PageRequest.of(0, limit)
        );
        
        // 转换为DTO
        return executions.stream()
            .map(TaskExecutionDTOAssembler::toDTO)
            .collect(Collectors.toList());
    }
    
    @Override
    public List<String> getExecutionLogs(String executionId) {
        // 获取执行记录
        TaskExecution execution = executionRepository.findById(TaskExecutionId.of(executionId))
            .orElseThrow(() -> new ExecutionNotFoundException("Execution not found: " + executionId));
        
        // 获取执行日志
        return executionLogRepository.findByExecutionId(executionId).stream()
            .map(ExecutionLog::getMessage)
            .collect(Collectors.toList());
    }
}
```

### platform-scheduler-register

**职责**：
- 实现任务注册和配置管理
- 提供任务模板和依赖关系管理
- 支持任务版本控制

**控制器实现**：

```java
/**
 * 任务控制器
 */
@RestController
@RequestMapping("/api/tasks")
public class TaskController {
    private final TaskApplicationService taskService;
    
    public TaskController(TaskApplicationService taskService) {
        this.taskService = taskService;
    }
    
    @PostMapping
    @PreAuthorize("hasAuthority('TASK_CREATE')")
    public ResponseEntity<TaskDTO> createTask(@RequestBody @Valid CreateTaskRequest request) {
        CreateTaskCommand command = CreateTaskCommand.builder()
            .name(request.getName())
            .description(request.getDescription())
            .type(request.getType())
            .config(request.getConfig())
            .priority(request.getPriority())
            .timeoutMinutes(request.getTimeoutMinutes())
            .retryStrategy(request.getRetryStrategy())
            .dependencies(request.getDependencies())
            .createdBy(SecurityUtils.getCurrentUsername())
            .build();
        
        TaskDTO task = taskService.createTask(command);
        
        return ResponseEntity
            .created(URI.create("/api/tasks/" + task.getId()))
            .body(task);
    }
    
    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority('TASK_READ')")
    public ResponseEntity<TaskDTO> getTask(@PathVariable String id) {
        TaskDTO task = taskService.getTaskById(id);
        return ResponseEntity.ok(task);
    }
    
    @GetMapping
    @PreAuthorize("hasAuthority('TASK_READ')")
    public ResponseEntity<Page<TaskDTO>> getTasks(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(required = false) String name,
            @RequestParam(required = false) TaskType type,
            @RequestParam(required = false) TaskStatus status) {
        
        GetTasksQuery query = GetTasksQuery.builder()
            .page(page)
            .size(size)
            .name(name)
            .type(type)
            .status(status)
            .build();
        
        Page<TaskDTO> tasks = taskService.getTasks(query);
        
        return ResponseEntity.ok(tasks);
    }
    
    @PutMapping("/{id}")
    @PreAuthorize("hasAuthority('TASK_UPDATE')")
    public ResponseEntity<TaskDTO> updateTask(
            @PathVariable String id,
            @RequestBody @Valid UpdateTaskRequest request) {
        
        UpdateTaskCommand command = UpdateTaskCommand.builder()
            .taskId(id)
            .name(request.getName())
            .description(request.getDescription())
            .config(request.getConfig())
            .priority(request.getPriority())
            .timeoutMinutes(request.getTimeoutMinutes())
            .retryStrategy(request.getRetryStrategy())
            .dependencies(request.getDependencies())
            .updatedBy(SecurityUtils.getCurrentUsername())
            .build();
        
        TaskDTO task = taskService.updateTask(command);
        
        return ResponseEntity.ok(task);
    }
    
    @DeleteMapping("/{id}")
    @PreAuthorize("hasAuthority('TASK_DELETE')")
    public ResponseEntity<Void> deleteTask(@PathVariable String id) {
        taskService.deleteTask(id, SecurityUtils.getCurrentUsername());
        return ResponseEntity.noContent().build();
    }
    
    @PostMapping("/{id}/activate")
    @PreAuthorize("hasAuthority('TASK_EXECUTE')")
    public ResponseEntity<TaskDTO> activateTask(@PathVariable String id) {
        TaskDTO task = taskService.activateTask(id, SecurityUtils.getCurrentUsername());
        return ResponseEntity.ok(task);
    }
    
    @PostMapping("/{id}/deactivate")
    @PreAuthorize("hasAuthority('TASK_EXECUTE')")
    public ResponseEntity<TaskDTO> deactivateTask(@PathVariable String id) {
        TaskDTO task = taskService.deactivateTask(id, SecurityUtils.getCurrentUsername());
        return ResponseEntity.ok(task);
    }
    
    @GetMapping("/{id}/dependencies")
    @PreAuthorize("hasAuthority('TASK_READ')")
    public ResponseEntity<List<TaskDTO>> getTaskDependencies(@PathVariable String id) {
        List<TaskDTO> dependencies = taskService.getTaskDependencies(id);
        return ResponseEntity.ok(dependencies);
    }
}

/**
 * 调度控制器
 */
@RestController
@RequestMapping("/api/schedules")
public class ScheduleController {
    private final ScheduleApplicationService scheduleService;
    
    public ScheduleController(ScheduleApplicationService scheduleService) {
        this.scheduleService = scheduleService;
    }
    
    @PostMapping
    @PreAuthorize("hasAuthority('SCHEDULE_CREATE')")
    public ResponseEntity<ScheduleDTO> createSchedule(@RequestBody @Valid CreateScheduleRequest request) {
        CreateScheduleCommand command = CreateScheduleCommand.builder()
            .taskId(request.getTaskId())
            .type(request.getType())
            .cronExpression(request.getCronExpression())
            .fixedRateSeconds(request.getFixedRateSeconds())
            .fixedDelaySeconds(request.getFixedDelaySeconds())
            .initialDelaySeconds(request.getInitialDelaySeconds())
            .oneTimeExecutionTime(request.getOneTimeExecutionTime())
            .timezone(request.getTimezone())
            .enabled(request.isEnabled())
            .startTime(request.getStartTime())
            .endTime(request.getEndTime())
            .createdBy(SecurityUtils.getCurrentUsername())
            .build();
        
        ScheduleDTO schedule = scheduleService.createSchedule(command);
        
        return ResponseEntity
            .created(URI.create("/api/schedules/" + schedule.getId()))
            .body(schedule);
    }
    
    @GetMapping("/task/{taskId}")
    @PreAuthorize("hasAuthority('SCHEDULE_READ')")
    public ResponseEntity<ScheduleDTO> getScheduleByTaskId(@PathVariable String taskId) {
        ScheduleDTO schedule = scheduleService.getScheduleByTaskId(taskId);
        return ResponseEntity.ok(schedule);
    }
    
    @PutMapping("/{id}")
    @PreAuthorize("hasAuthority('SCHEDULE_UPDATE')")
    public ResponseEntity<ScheduleDTO> updateSchedule(
            @PathVariable String id,
            @RequestBody @Valid UpdateScheduleRequest request) {
        
        UpdateScheduleCommand command = UpdateScheduleCommand.builder()
            .scheduleId(id)
            .type(request.getType())
            .cronExpression(request.getCronExpression())
            .fixedRateSeconds(request.getFixedRateSeconds())
            .fixedDelaySeconds(request.getFixedDelaySeconds())
            .initialDelaySeconds(request.getInitialDelaySeconds())
            .oneTimeExecutionTime(request.getOneTimeExecutionTime())
            .timezone(request.getTimezone())
            .enabled(request.getEnabled())
            .startTime(request.getStartTime())
            .endTime(request.getEndTime())
            .updatedBy(SecurityUtils.getCurrentUsername())
            .build();
        
        ScheduleDTO schedule = scheduleService.updateSchedule(command);
        
        return ResponseEntity.ok(schedule);
    }
    
    @PostMapping("/{id}/enable")
    @PreAuthorize("hasAuthority('SCHEDULE_UPDATE')")
    public ResponseEntity<ScheduleDTO> enableSchedule(@PathVariable String id) {
        ScheduleDTO schedule = scheduleService.enableSchedule(id, SecurityUtils.getCurrentUsername());
        return ResponseEntity.ok(schedule);
    }
    
    @PostMapping("/{id}/disable")
    @PreAuthorize("hasAuthority('SCHEDULE_UPDATE')")
    public ResponseEntity<ScheduleDTO> disableSchedule(@PathVariable String id) {
        ScheduleDTO schedule = scheduleService.disableSchedule(id, SecurityUtils.getCurrentUsername());
        return ResponseEntity.ok(schedule);
    }
    
    @GetMapping("/{id}/next-execution-time")
    @PreAuthorize("hasAuthority('SCHEDULE_READ')")
    public ResponseEntity<Map<String, Object>> getNextExecutionTime(@PathVariable String id) {
        LocalDateTime nextExecutionTime = scheduleService.getNextExecutionTime(id);
        
        Map<String, Object> response = new HashMap<>();
        response.put("scheduleId", id);
        response.put("nextExecutionTime", nextExecutionTime);
        
        return ResponseEntity.ok(response);
    }
}
```

### platform-scheduler-executor

**职责**：
- 实现任务执行器
- 提供不同类型任务的执行环境
- 支持资源管理和负载均衡

**执行引擎设计**：

```java
/**
 * 执行引擎接口
 */
public interface ExecutionEngine {
    /**
     * 执行任务
     * @param task 任务
     * @param execution 执行记录
     */
    void execute(Task task, TaskExecution execution);
    
    /**
     * 停止执行
     * @param executionId 执行ID
     */
    void stopExecution(TaskExecutionId executionId);
    
    /**
     * 获取执行状态
     * @param executionId 执行ID
     * @return 执行状态
     */
    ExecutionStatus getExecutionStatus(TaskExecutionId executionId);
}

/**
 * 执行引擎实现
 */
@Component
public class TaskExecutionEngine implements ExecutionEngine {
    private static final Logger logger = LoggerFactory.getLogger(TaskExecutionEngine.class);
    
    private final TaskExecutorFactory taskExecutorFactory;
    private final TaskExecutionRepository executionRepository;
    private final ExecutionLogRepository executionLogRepository;
    private final DomainEventPublisher eventPublisher;
    private final Map<String, ExecutionContext> runningExecutions = new ConcurrentHashMap<>();
    
    @Override
    public void execute(Task task, TaskExecution execution) {
        String executionId = execution.getId().getValue();
        
        try {
            // 创建执行上下文
            ExecutionContext context = new ExecutionContext(
                executionId,
                task.getId().getValue(),
                task.getConfig(),
                execution.getParameters()
            );
            
            // 记录开始
            context.setStartTime(LocalDateTime.now());
            context.setStatus(ExecutionStatus.RUNNING);
            
            // 添加到运行中的执行
            runningExecutions.put(executionId, context);
            
            // 更新执行状态
            execution.start();
            executionRepository.save(execution);
            
            // 发布执行开始事件
            eventPublisher.publish(new TaskExecutionStartedEvent(
                executionId,
                task.getId().getValue()
            ));
            
            // 记录执行日志
            logExecution(executionId, "Execution started");
            
            // 获取任务执行器
            TaskExecutor taskExecutor = taskExecutorFactory.getExecutor(task.getType());
            
            // 执行任务
            ExecutionResult result = taskExecutor.execute(context);
            
            // 记录执行结果
            context.setEndTime(LocalDateTime.now());
            context.setResult(result);
            context.setStatus(ExecutionStatus.COMPLETED);
            
            // 更新执行记录
            execution.complete(result);
            executionRepository.save(execution);
            
            // 发布执行完成事件
            eventPublisher.publish(new TaskExecutionCompletedEvent(
                executionId,
                task.getId().getValue(),
                "COMPLETED"
            ));
            
            // 记录执行日志
            logExecution(executionId, "Execution completed successfully");
            
        } catch (Exception e) {
            // 记录异常
            logger.error("Failed to execute task: {}, execution: {}", 
                task.getId().getValue(), executionId, e);
            
            // 更新上下文
            ExecutionContext context = runningExecutions.get(executionId);
            if (context != null) {
                context.setEndTime(LocalDateTime.now());
                context.setStatus(ExecutionStatus.FAILED);
                context.setErrorMessage(e.getMessage());
            }
            
            // 更新执行记录
            execution.fail(e.getMessage());
            executionRepository.save(execution);
            
            // 发布执行失败事件
            eventPublisher.publish(new TaskExecutionFailedEvent(
                executionId,
                task.getId().getValue(),
                e.getMessage()
            ));
            
            // 记录执行日志
            logExecution(executionId, "Execution failed: " + e.getMessage());
            
        } finally {
            // 从运行中的执行中移除
            runningExecutions.remove(executionId);
        }
    }
    
    @Override
    public void stopExecution(TaskExecutionId executionId) {
        String execId = executionId.getValue();
        
        // 获取执行上下文
        ExecutionContext context = runningExecutions.get(execId);
        if (context == null) {
            logger.warn("Execution not found or already completed: {}", execId);
            return;
        }
        
        // 设置停止标志
        context.setStopped(true);
        
        // 等待执行停止
        int retryCount = 0;
        while (runningExecutions.containsKey(execId) && retryCount < 10) {
            try {
                Thread.sleep(100);
                retryCount++;
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        // 如果执行仍在运行，强制移除
        if (runningExecutions.containsKey(execId)) {
            logger.warn("Execution did not stop gracefully, forcing removal: {}", execId);
            runningExecutions.remove(execId);
        }
        
        // 记录执行日志
        logExecution(execId, "Execution stopped by user");
    }
    
    @Override
    public ExecutionStatus getExecutionStatus(TaskExecutionId executionId) {
        String execId = executionId.getValue();
        
        // 获取执行上下文
        ExecutionContext context = runningExecutions.get(execId);
        if (context != null) {
            return context.getStatus();
        }
        
        // 如果执行不在内存中，从数据库查询
        return executionRepository.findById(executionId)
            .map(TaskExecution::getStatus)
            .orElse(ExecutionStatus.UNKNOWN);
    }
    
    private void logExecution(String executionId, String message) {
        ExecutionLog log = new ExecutionLog(
            ExecutionLogId.generate(),
            executionId,
            message,
            LocalDateTime.now()
        );
        
        executionLogRepository.save(log);
    }
}

/**
 * 任务执行器接口
 */
public interface TaskExecutor {
    /**
     * 执行任务
     * @param context 执行上下文
     * @return 执行结果
     */
    ExecutionResult execute(ExecutionContext context);
    
    /**
     * 获取执行器支持的任务类型
     * @return 任务类型
     */
    TaskType getType();
}

/**
 * 执行上下文
 */
public class ExecutionContext {
    private final String executionId;
    private final String taskId;
    private final TaskConfig taskConfig;
    private final Map<String, Object> parameters;
    
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private ExecutionStatus status = ExecutionStatus.PENDING;
    private ExecutionResult result;
    private String errorMessage;
    private boolean stopped = false;
    
    // 构造函数和getter/setter
}
```

### platform-scheduler-query

**职责**：
- 实现任务查询和监控功能
- 提供执行历史和日志查询
- 支持任务统计和分析

**控制器实现**：

```java
/**
 * 执行控制器
 */
@RestController
@RequestMapping("/api/executions")
public class ExecutionController {
    private final ExecutionApplicationService executionService;
    
    public ExecutionController(ExecutionApplicationService executionService) {
        this.executionService = executionService;
    }
    
    @PostMapping("/tasks/{taskId}")
    @PreAuthorize("hasAuthority('TASK_EXECUTE')")
    public ResponseEntity<TaskExecutionDTO> executeTask(
            @PathVariable String taskId,
            @RequestBody(required = false) Map<String, Object> parameters) {
        
        ExecuteTaskCommand command = ExecuteTaskCommand.builder()
            .taskId(taskId)
            .parameters(parameters)
            .executedBy(SecurityUtils.getCurrentUsername())
            .build();
        
        TaskExecutionDTO execution = executionService.executeTask(command);
        
        return ResponseEntity
            .accepted()
            .body(execution);
    }
    
    @PostMapping("/{id}/stop")
    @PreAuthorize("hasAuthority('TASK_EXECUTE')")
    public ResponseEntity<Void> stopExecution(
            @PathVariable String id,
            @RequestParam(required = false, defaultValue = "Stopped by user") String reason) {
        
        executionService.stopExecution(id, reason);
        
        return ResponseEntity.accepted().build();
    }
    
    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority('TASK_READ')")
    public ResponseEntity<TaskExecutionDTO> getExecutionStatus(@PathVariable String id) {
        TaskExecutionDTO execution = executionService.getExecutionStatus(id);
        return ResponseEntity.ok(execution);
    }
    
    @GetMapping("/tasks/{taskId}")
    @PreAuthorize("hasAuthority('TASK_READ')")
    public ResponseEntity<List<TaskExecutionDTO>> getTaskExecutionHistory(
            @PathVariable String taskId,
            @RequestParam(defaultValue = "10") int limit) {
        
        List<TaskExecutionDTO> executions = executionService.getTaskExecutionHistory(taskId, limit);
        
        return ResponseEntity.ok(executions);
    }
    
    @GetMapping("/{id}/logs")
    @PreAuthorize("hasAuthority('TASK_READ')")
    public ResponseEntity<List<String>> getExecutionLogs(@PathVariable String id) {
        List<String> logs = executionService.getExecutionLogs(id);
        return ResponseEntity.ok(logs);
    }
}

/**
 * 任务统计控制器
 */
@RestController
@RequestMapping("/api/statistics")
public class StatisticsController {
    private final StatisticsService statisticsService;
    
    public StatisticsController(StatisticsService statisticsService) {
        this.statisticsService = statisticsService;
    }
    
    @GetMapping("/tasks/summary")
    @PreAuthorize("hasAuthority('STATISTICS_READ')")
    public ResponseEntity<TaskSummaryDTO> getTaskSummary() {
        TaskSummaryDTO summary = statisticsService.getTaskSummary();
        return ResponseEntity.ok(summary);
    }
    
    @GetMapping("/tasks/status")
    @PreAuthorize("hasAuthority('STATISTICS_READ')")
    public ResponseEntity<Map<TaskStatus, Long>> getTaskStatusCounts() {
        Map<TaskStatus, Long> counts = statisticsService.getTaskStatusCounts();
        return ResponseEntity.ok(counts);
    }
    
    @GetMapping("/executions/summary")
    @PreAuthorize("hasAuthority('STATISTICS_READ')")
    public ResponseEntity<ExecutionSummaryDTO> getExecutionSummary(
            @RequestParam(required = false) LocalDate startDate,
            @RequestParam(required = false) LocalDate endDate) {
        
        ExecutionSummaryDTO summary = statisticsService.getExecutionSummary(startDate, endDate);
        return ResponseEntity.ok(summary);
    }
    
    @GetMapping("/executions/status")
    @PreAuthorize("hasAuthority('STATISTICS_READ')")
    public ResponseEntity<Map<ExecutionStatus, Long>> getExecutionStatusCounts(
            @RequestParam(required = false) LocalDate startDate,
            @RequestParam(required = false) LocalDate endDate) {
        
        Map<ExecutionStatus, Long> counts = statisticsService.getExecutionStatusCounts(startDate, endDate);
        return ResponseEntity.ok(counts);
    }
    
    @GetMapping("/executions/duration")
    @PreAuthorize("hasAuthority('STATISTICS_READ')")
    public ResponseEntity<List<TaskExecutionTimeDTO>> getTaskExecutionTimes(
            @RequestParam(required = false) LocalDate startDate,
            @RequestParam(required = false) LocalDate endDate,
            @RequestParam(defaultValue = "10") int limit) {
        
        List<TaskExecutionTimeDTO> executionTimes = statisticsService.getTaskExecutionTimes(
            startDate,
            endDate,
            limit
        );
        
        return ResponseEntity.ok(executionTimes);
    }
}
```

**统计服务实现**：

```java
/**
 * 统计服务接口
 */
public interface StatisticsService {
    /**
     * 获取任务摘要
     * @return 任务摘要
     */
    TaskSummaryDTO getTaskSummary();
    
    /**
     * 获取任务状态统计
     * @return 任务状态统计
     */
    Map<TaskStatus, Long> getTaskStatusCounts();
    
    /**
     * 获取执行摘要
     * @param startDate 开始日期
     * @param endDate 结束日期
     * @return 执行摘要
     */
    ExecutionSummaryDTO getExecutionSummary(LocalDate startDate, LocalDate endDate);
    
    /**
     * 获取执行状态统计
     * @param startDate 开始日期
     * @param endDate 结束日期
     * @return 执行状态统计
     */
    Map<ExecutionStatus, Long> getExecutionStatusCounts(LocalDate startDate, LocalDate endDate);
    
    /**
     * 获取任务执行时间统计
     * @param startDate 开始日期
     * @param endDate 结束日期
     * @param limit 限制数量
     * @return 任务执行时间统计
     */
    List<TaskExecutionTimeDTO> getTaskExecutionTimes(LocalDate startDate, LocalDate endDate, int limit);
}

/**
 * 统计服务实现
 */
@Service
public class StatisticsServiceImpl implements StatisticsService {
    private final TaskRepository taskRepository;
    private final TaskExecutionRepository executionRepository;
    
    @Override
    public TaskSummaryDTO getTaskSummary() {
        long totalTasks = taskRepository.count();
        long activeTasks = taskRepository.countByStatus(TaskStatus.ACTIVE);
        long inactiveTasks = taskRepository.countByStatus(TaskStatus.INACTIVE);
        
        return TaskSummaryDTO.builder()
            .totalTasks(totalTasks)
            .activeTasks(activeTasks)
            .inactiveTasks(inactiveTasks)
            .build();
    }
    
    @Override
    public Map<TaskStatus, Long> getTaskStatusCounts() {
        return taskRepository.countByStatusGrouped();
    }
    
    @Override
    public ExecutionSummaryDTO getExecutionSummary(LocalDate startDate, LocalDate endDate) {
        // 设置默认日期范围
        LocalDate start = startDate != null ? startDate : LocalDate.now().minusMonths(1);
        LocalDate end = endDate != null ? endDate : LocalDate.now();
        
        // 转换为日期时间
        LocalDateTime startDateTime = start.atStartOfDay();
        LocalDateTime endDateTime = end.atTime(23, 59, 59);
        
        // 查询执行统计
        long totalExecutions = executionRepository.countByStartTimeBetween(startDateTime, endDateTime);
        long successfulExecutions = executionRepository.countByStatusAndStartTimeBetween(
            ExecutionStatus.COMPLETED, startDateTime, endDateTime);
        long failedExecutions = executionRepository.countByStatusAndStartTimeBetween(
            ExecutionStatus.FAILED, startDateTime, endDateTime);
        long runningExecutions = executionRepository.countByStatusAndStartTimeBetween(
            ExecutionStatus.RUNNING, startDateTime, endDateTime);
        
        // 查询平均执行时间
        Double avgExecutionTime = executionRepository.getAverageExecutionTime(startDateTime, endDateTime);
        
        return ExecutionSummaryDTO.builder()
            .totalExecutions(totalExecutions)
            .successfulExecutions(successfulExecutions)
            .failedExecutions(failedExecutions)
            .runningExecutions(runningExecutions)
            .averageExecutionTimeMs(avgExecutionTime != null ? avgExecutionTime.longValue() : 0)
            .startDate(start)
            .endDate(end)
            .build();
    }
    
    @Override
    public Map<ExecutionStatus, Long> getExecutionStatusCounts(LocalDate startDate, LocalDate endDate) {
        // 设置默认日期范围
        LocalDate start = startDate != null ? startDate : LocalDate.now().minusMonths(1);
        LocalDate end = endDate != null ? endDate : LocalDate.now();
        
        // 转换为日期时间
        LocalDateTime startDateTime = start.atStartOfDay();
        LocalDateTime endDateTime = end.atTime(23, 59, 59);
        
        return executionRepository.countByStatusGroupedAndStartTimeBetween(startDateTime, endDateTime);
    }
    
    @Override
    public List<TaskExecutionTimeDTO> getTaskExecutionTimes(LocalDate startDate, LocalDate endDate, int limit) {
        // 设置默认日期范围
        LocalDate start = startDate != null ? startDate : LocalDate.now().minusMonths(1);
        LocalDate end = endDate != null ? endDate : LocalDate.now();
        
        // 转换为日期时间
        LocalDateTime startDateTime = start.atStartOfDay();
        LocalDateTime endDateTime = end.atTime(23, 59, 59);
        
        // 查询任务执行时间
        List<Object[]> results = executionRepository.getTaskExecutionTimes(
            startDateTime, endDateTime, PageRequest.of(0, limit));
        
        return results.stream().map(result -> {
            String taskId = (String) result[0];
            String taskName = (String) result[1];
            Long avgTime = ((Number) result[2]).longValue();
            Long minTime = ((Number) result[3]).longValue();
            Long maxTime = ((Number) result[4]).longValue();
            Long executions = ((Number) result[5]).longValue();
            
            return TaskExecutionTimeDTO.builder()
                .taskId(taskId)
                .taskName(taskName)
                .averageExecutionTimeMs(avgTime)
                .minExecutionTimeMs(minTime)
                .maxExecutionTimeMs(maxTime)
                .executionCount(executions)
                .build();
        }).collect(Collectors.toList());
    }
}
```

## 配置范例

```yaml
spring:
  application:
    name: platform-scheduler
  datasource:
    url: jdbc:mysql://${MYSQL_HOST:localhost}:${MYSQL_PORT:3306}/${MYSQL_DATABASE:scheduler_db}?useSSL=false&serverTimezone=UTC
    username: ${MYSQL_USERNAME:root}
    password: ${MYSQL_PASSWORD:password}
    driver-class-name: com.mysql.cj.jdbc.Driver
  redis:
    host: ${REDIS_HOST:localhost}
    port: ${REDIS_PORT:6379}
    password: ${REDIS_PASSWORD:}
  jpa:
    hibernate:
      ddl-auto: validate
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MySQL8Dialect
    open-in-view: false
  quartz:
    job-store-type: jdbc
    properties:
      org.quartz.jobStore.isClustered: true
      org.quartz.jobStore.clusterCheckinInterval: 20000
      org.quartz.jobStore.driverDelegateClass: org.quartz.impl.jdbcjobstore.StdJDBCDelegate

# 调度系统配置
scheduler:
  executor:
    core-pool-size: 10
    max-pool-size: 20
    queue-capacity: 100
    thread-name-prefix: scheduler-task-
  retry:
    max-attempts: 3
    initial-interval-seconds: 5
    multiplier: 2.0
  distributed-lock:
    registry-key: scheduler:locks
    lock-acquire-timeout-millis: 10000
    lock-lease-time-millis: 60000
  task-execution:
    max-concurrent-tasks: 20
    default-timeout-minutes: 60
    log-retention-days: 30
  cron:
    timezone: UTC

server:
  port: 8082

management:
  endpoints:
    web:
      exposure:
        include: '*'
  endpoint:
    health:
      show-details: ALWAYS
```