# 基础架构服务设计

## 1. platform-registry (服务注册与发现)

**设计目标**：
实现高可用的服务注册与发现中心，为所有微服务提供服务注册、发现和健康监测功能。

**核心功能**：
1. 服务注册：微服务启动时自动注册到注册中心
2. 服务发现：提供服务实例查询和负载均衡能力
3. 健康检查：定期检查服务实例健康状态
4. 配置联动：与配置中心集成，支持服务配置动态刷新
5. 多环境支持：支持开发、测试、生产等多环境隔离

**技术选型**：
- 基于Nacos实现，支持AP和CP两种一致性模型
- 使用Spring Cloud Alibaba Nacos Discovery集成
- 采用集群部署模式确保高可用

**关键设计**：
```java
@SpringBootApplication
@EnableNacosDiscovery
public class PlatformRegistryApplication {
    public static void main(String[] args) {
        SpringApplication.run(PlatformRegistryApplication.class, args);
    }
    
    @Bean
    public NacosServiceRegistry nacosServiceRegistry(NacosDiscoveryProperties properties) {
        return new NacosServiceRegistry(properties);
    }
    
    @Bean
    public NacosRegistration nacosRegistration(NacosDiscoveryProperties properties) {
        return new NacosRegistration(properties);
    }
}
```

**配置范例**：
```yaml
spring:
  application:
    name: platform-registry
  cloud:
    nacos:
      discovery:
        server-addr: ${NACOS_SERVER:localhost:8848}
        namespace: ${NACOS_NAMESPACE:platform}
        cluster-name: ${NACOS_CLUSTER:DEFAULT}
        heart-beat-interval: 5000
        heart-beat-timeout: 15000
        metadata:
          preserved.heart.beat.interval: 5000
          preserved.heart.beat.timeout: 15000
          preserved.ip.delete.timeout: 30000
      
server:
  port: 8848

management:
  endpoints:
    web:
      exposure:
        include: '*'
  endpoint:
    health:
      show-details: ALWAYS
```

**安全与高可用设计**：
1. 认证鉴权：集成Spring Security实现访问控制
2. 集群同步：基于Raft协议的集群一致性
3. 数据持久化：支持MySQL或嵌入式Derby数据库
4. 自动扩缩容：支持Kubernetes环境下的弹性伸缩

**限界上下文映射**：
- 与API网关上下文的关系：供应商-消费者关系
- 与配置中心上下文的关系：共享内核关系
- 与所有业务服务上下文的关系：供应商-消费者关系

**接口定义**：
```java
/**
 * 服务注册中心门面接口
 * 定义注册中心对外提供的核心服务能力
 */
public interface RegistryCenterFacade {
    /**
     * 获取服务实例列表
     * @param serviceName 服务名称
     * @return 服务实例列表
     */
    List<ServiceInstance> getInstances(String serviceName);
    
    /**
     * 获取所有服务名称
     * @return 服务名称列表
     */
    List<String> getServices();
    
    /**
     * 注册服务实例
     * @param registration 服务注册信息
     */
    void register(Registration registration);
    
    /**
     * 注销服务实例
     * @param registration 服务注册信息
     */
    void deregister(Registration registration);
    
    /**
     * 更新服务实例状态
     * @param registration 服务注册信息
     * @param status 服务状态
     */
    void setStatus(Registration registration, String status);
}
```

## 2. platform-gateway (API网关)

**设计目标**：
构建统一的API入口，实现请求路由、负载均衡、认证授权、限流熔断等功能，为前端应用提供一站式API访问体验。

**核心功能**：
1. 请求路由：基于服务名称或路径的动态路由
2. 统一认证：集成OAuth2/JWT实现身份认证
3. 请求限流：基于IP、用户、API的限流控制
4. 熔断降级：实现故障服务的熔断与降级
5. 请求过滤：跨域处理、请求头转换等
6. 监控审计：请求日志记录与监控指标收集

**技术选型**：
- 基于Spring Cloud Gateway实现
- 使用Redis实现分布式限流
- 基于Resilience4j实现熔断与重试

**关键设计**：
```java
@SpringBootApplication
@EnableDiscoveryClient
public class PlatformGatewayApplication {
    public static void main(String[] args) {
        SpringApplication.run(PlatformGatewayApplication.class, args);
    }
    
    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
            .route("auth-service", r -> r.path("/auth/**")
                .filters(f -> f.stripPrefix(1)
                              .requestRateLimiter(c -> c.setRateLimiter(redisRateLimiter())))
                .uri("lb://platform-auth-service"))
            .route("data-service", r -> r.path("/data/**")
                .filters(f -> f.stripPrefix(1)
                              .circuitBreaker(c -> c.setName("dataServiceCircuitBreaker")
                                                   .setFallbackUri("forward:/fallback/data")))
                .uri("lb://platform-data-service"))
            // 其他路由定义...
            .build();
    }
    
    @Bean
    public RedisRateLimiter redisRateLimiter() {
        return new RedisRateLimiter(10, 20); // 令牌桶限流
    }
}
```

**配置范例**：
```yaml
spring:
  application:
    name: platform-gateway
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true
          lower-case-service-id: true
      routes:
        - id: auth-service
          uri: lb://platform-auth-service
          predicates:
            - Path=/auth/**
          filters:
            - StripPrefix=1
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 10
                redis-rate-limiter.burstCapacity: 20
        - id: data-service
          uri: lb://platform-data-service
          predicates:
            - Path=/data/**
          filters:
            - StripPrefix=1
            - name: CircuitBreaker
              args:
                name: dataServiceCircuitBreaker
                fallbackUri: forward:/fallback/data

server:
  port: 8080

management:
  endpoints:
    web:
      exposure:
        include: '*'
  endpoint:
    gateway:
      enabled: true
    health:
      show-details: ALWAYS
```

**安全设计**：
1. JWT验证：验证请求中的JWT令牌
2. 黑名单IP控制：阻止恶意IP访问
3. 请求加密：支持HTTPS通信
4. 数据脱敏：敏感信息在日志中自动脱敏
5. 访问控制：基于角色的API访问控制

**性能优化**：
1. 路由缓存：缓存路由信息提高查找效率
2. 异步处理：使用Reactor模式处理请求
3. 连接池管理：优化与后端服务的连接池配置
4. 请求合并：合并对同一微服务的多个请求

**限界上下文映射**：
- 与认证授权上下文的关系：消费者-供应商关系
- 与服务注册上下文的关系：消费者-供应商关系
- 与业务服务上下文的关系：防腐层

## 3. platform-auth-service (统一认证授权服务)

**设计目标**：
建立企业级统一身份认证和授权服务，为所有应用提供安全、可靠的身份验证和权限管理。

**核心功能**：
1. 用户认证：支持多种认证方式（用户名密码、手机验证码、第三方OAuth等）
2. 权限管理：基于RBAC模型的细粒度权限控制
3. 令牌管理：JWT令牌的颁发、验证和撤销
4. 会话管理：用户会话状态维护
5. 安全审计：认证授权操作的完整日志记录

**领域模型**：
1. 用户聚合：User(聚合根)、UserProfile、Credential
2. 角色聚合：Role(聚合根)、RolePermission
3. 权限聚合：Permission(聚合根)、PermissionGroup、Resource
4. 租户聚合：Tenant(聚合根)、TenantConfig

**技术选型**：
- 基于Spring Security和OAuth2实现
- 使用JWT作为令牌格式
- Redis存储会话和令牌状态

**领域模型代码示例**：

```java
/**
 * 用户聚合根
 */
@Entity
@Table(name = "auth_user")
public class User implements AggregateRoot<UserId> {
    @EmbeddedId
    private UserId id;
    
    @Column(name = "username", unique = true, nullable = false)
    private String username;
    
    @Embedded
    private Password password;
    
    @Column(name = "email", unique = true, nullable = false)
    private Email email;
    
    @Column(name = "phone", unique = true)
    private Phone phone;
    
    @Column(name = "enabled", nullable = false)
    private boolean enabled;
    
    @Column(name = "account_non_locked", nullable = false)
    private boolean accountNonLocked;
    
    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(name = "auth_user_roles", joinColumns = @JoinColumn(name = "user_id"))
    @Column(name = "role_id")
    private Set<RoleId> roleIds = new HashSet<>();
    
    protected User() {} // For JPA
    
    public User(UserId id, String username, Password password, Email email) {
        this.id = id;
        this.username = username;
        this.password = password;
        this.email = email;
        this.enabled = false;
        this.accountNonLocked = true;
    }
    
    public void changePassword(Password currentPassword, Password newPassword, PasswordEncoder encoder) {
        if (!currentPassword.matches(this.password, encoder)) {
            throw new InvalidCredentialsException("Current password is incorrect");
        }
        
        this.password = newPassword;
    }
    
    public void assignRole(RoleId roleId) {
        roleIds.add(roleId);
    }
    
    public void removeRole(RoleId roleId) {
        roleIds.remove(roleId);
    }
    
    public void enable() {
        this.enabled = true;
    }
    
    public void disable() {
        this.enabled = false;
    }
    
    public void lock() {
        this.accountNonLocked = false;
    }
    
    public void unlock() {
        this.accountNonLocked = true;
    }
    
    @Override
    public UserId getId() {
        return id;
    }
    
    // Getter methods only - no setters to protect invariants
    public String getUsername() {
        return username;
    }
    
    public Password getPassword() {
        return password;
    }
    
    public Email getEmail() {
        return email;
    }
    
    public Phone getPhone() {
        return phone;
    }
    
    public boolean isEnabled() {
        return enabled;
    }
    
    public boolean isAccountNonLocked() {
        return accountNonLocked;
    }
    
    public Set<RoleId> getRoleIds() {
        return Collections.unmodifiableSet(roleIds);
    }
}

/**
 * 用户ID值对象
 */
@Embeddable
public class UserId implements ValueObject {
    @Column(name = "id")
    private String value;
    
    protected UserId() {} // For JPA
    
    private UserId(String value) {
        this.value = value;
    }
    
    public static UserId of(String value) {
        if (value == null || value.trim().isEmpty()) {
            throw new IllegalArgumentException("User ID cannot be null or empty");
        }
        return new UserId(value);
    }
    
    public static UserId generate() {
        return new UserId(UUID.randomUUID().toString());
    }
    
    public String getValue() {
        return value;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        UserId userId = (UserId) o;
        return Objects.equals(value, userId.value);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(value);
    }
}

/**
 * 密码值对象
 */
@Embeddable
public class Password implements ValueObject {
    @Column(name = "password", nullable = false)
    private String hashedValue;
    
    protected Password() {} // For JPA
    
    private Password(String hashedValue) {
        this.hashedValue = hashedValue;
    }
    
    public static Password fromPlainText(String plainText, PasswordEncoder encoder) {
        if (plainText == null || plainText.trim().isEmpty()) {
            throw new IllegalArgumentException("Password cannot be null or empty");
        }
        
        validatePasswordStrength(plainText);
        return new Password(encoder.encode(plainText));
    }
    
    public static Password fromHashed(String hashedValue) {
        if (hashedValue == null || hashedValue.trim().isEmpty()) {
            throw new IllegalArgumentException("Hashed password cannot be null or empty");
        }
        return new Password(hashedValue);
    }
    
    public boolean matches(Password plainTextPassword, PasswordEncoder encoder) {
        return encoder.matches(plainTextPassword.hashedValue, this.hashedValue);
    }
    
    private static void validatePasswordStrength(String password) {
        // 实现密码强度验证逻辑
        if (password.length() < 8) {
            throw new WeakPasswordException("Password must be at least 8 characters long");
        }
        
        // 检查是否包含大小写字母和数字
        boolean hasUppercase = !password.equals(password.toLowerCase());
        boolean hasLowercase = !password.equals(password.toUpperCase());
        boolean hasDigit = password.matches(".*\\d.*");
        
        if (!(hasUppercase && hasLowercase && hasDigit)) {
            throw new WeakPasswordException("Password must contain uppercase, lowercase letters and digits");
        }
    }
    
    public String getHashedValue() {
        return hashedValue;
    }
}
```

**应用服务层**：

```java
/**
 * 用户应用服务
 */
@Service
@Transactional
public class UserApplicationService {
    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    private final PasswordEncoder passwordEncoder;
    private final DomainEventPublisher eventPublisher;
    
    public UserApplicationService(UserRepository userRepository, 
                                 RoleRepository roleRepository,
                                 PasswordEncoder passwordEncoder,
                                 DomainEventPublisher eventPublisher) {
        this.userRepository = userRepository;
        this.roleRepository = roleRepository;
        this.passwordEncoder = passwordEncoder;
        this.eventPublisher = eventPublisher;
    }
    
    public UserDTO createUser(CreateUserCommand command) {
        // 检查用户名是否已存在
        if (userRepository.existsByUsername(command.getUsername())) {
            throw new UsernameDuplicateException(command.getUsername());
        }
        
        // 检查邮箱是否已存在
        if (userRepository.existsByEmail(Email.of(command.getEmail()))) {
            throw new EmailDuplicateException(command.getEmail());
        }
        
        // 创建用户实体
        User user = new User(
            UserId.generate(),
            command.getUsername(),
            Password.fromPlainText(command.getPassword(), passwordEncoder),
            Email.of(command.getEmail())
        );
        
        // 分配默认角色
        command.getRoleIds().forEach(roleId -> {
            RoleId id = RoleId.of(roleId);
            if (roleRepository.existsById(id)) {
                user.assignRole(id);
            } else {
                throw new RoleNotFoundException(roleId);
            }
        });
        
        // 启用账号
        if (command.isEnabled()) {
            user.enable();
        }
        
        // 保存用户
        userRepository.save(user);
        
        // 发布领域事件
        eventPublisher.publish(new UserCreatedEvent(user.getId().getValue(), user.getUsername()));
        
        // 返回DTO
        return UserDTOAssembler.toDTO(user);
    }
    
    public UserDTO updateUser(UpdateUserCommand command) {
        // 获取用户
        User user = userRepository.findById(UserId.of(command.getUserId()))
            .orElseThrow(() -> new UserNotFoundException(command.getUserId()));
        
        // 更新邮箱
        if (command.getEmail() != null && !command.getEmail().equals(user.getEmail().getValue())) {
            if (userRepository.existsByEmail(Email.of(command.getEmail()))) {
                throw new EmailDuplicateException(command.getEmail());
            }
            user = user.withEmail(Email.of(command.getEmail()));
        }
        
        // 更新角色
        if (command.getRoleIds() != null) {
            // 清空现有角色
            Set<RoleId> currentRoles = new HashSet<>(user.getRoleIds());
            currentRoles.forEach(user::removeRole);
            
            // 分配新角色
            command.getRoleIds().forEach(roleId -> {
                RoleId id = RoleId.of(roleId);
                if (roleRepository.existsById(id)) {
                    user.assignRole(id);
                } else {
                    throw new RoleNotFoundException(roleId);
                }
            });
        }
        
        // 启用/禁用账号
        if (command.getEnabled() != null) {
            if (command.getEnabled()) {
                user.enable();
            } else {
                user.disable();
            }
        }
        
        // 保存用户
        userRepository.save(user);
        
        // 发布领域事件
        eventPublisher.publish(new UserUpdatedEvent(user.getId().getValue()));
        
        // 返回DTO
        return UserDTOAssembler.toDTO(user);
    }
    
    public void changePassword(ChangePasswordCommand command) {
        // 获取用户
        User user = userRepository.findById(UserId.of(command.getUserId()))
            .orElseThrow(() -> new UserNotFoundException(command.getUserId()));
        
        // 更改密码
        user.changePassword(
            Password.fromPlainText(command.getCurrentPassword(), passwordEncoder),
            Password.fromPlainText(command.getNewPassword(), passwordEncoder),
            passwordEncoder
        );
        
        // 保存用户
        userRepository.save(user);
        
        // 发布领域事件
        eventPublisher.publish(new PasswordChangedEvent(user.getId().getValue()));
    }
    
    public void deleteUser(DeleteUserCommand command) {
        // 获取用户
        User user = userRepository.findById(UserId.of(command.getUserId()))
            .orElseThrow(() -> new UserNotFoundException(command.getUserId()));
        
        // 删除用户
        userRepository.delete(user);
        
        // 发布领域事件
        eventPublisher.publish(new UserDeletedEvent(command.getUserId()));
    }
}
```

**接口层**：

```java
/**
 * 用户控制器
 */
@RestController
@RequestMapping("/api/users")
public class UserController {
    private final UserApplicationService userService;
    
    public UserController(UserApplicationService userService) {
        this.userService = userService;
    }
    
    @PostMapping
    @PreAuthorize("hasAuthority('USER_CREATE')")
    public ResponseEntity<UserDTO> createUser(@RequestBody @Valid CreateUserRequest request) {
        CreateUserCommand command = CreateUserCommand.builder()
            .username(request.getUsername())
            .password(request.getPassword())
            .email(request.getEmail())
            .roleIds(request.getRoleIds())
            .enabled(request.isEnabled())
            .build();
        
        UserDTO user = userService.createUser(command);
        
        return ResponseEntity
            .created(URI.create("/api/users/" + user.getId()))
            .body(user);
    }
    
    @PutMapping("/{userId}")
    @PreAuthorize("hasAuthority('USER_UPDATE')")
    public ResponseEntity<UserDTO> updateUser(
            @PathVariable String userId,
            @RequestBody @Valid UpdateUserRequest request) {
        
        UpdateUserCommand command = UpdateUserCommand.builder()
            .userId(userId)
            .email(request.getEmail())
            .roleIds(request.getRoleIds())
            .enabled(request.getEnabled())
            .build();
        
        UserDTO user = userService.updateUser(command);
        
        return ResponseEntity.ok(user);
    }
    
    @PostMapping("/{userId}/password")
    @PreAuthorize("hasAuthority('USER_CHANGE_PASSWORD') or #userId == authentication.principal.id")
    public ResponseEntity<Void> changePassword(
            @PathVariable String userId,
            @RequestBody @Valid ChangePasswordRequest request) {
        
        ChangePasswordCommand command = new ChangePasswordCommand(
            userId,
            request.getCurrentPassword(),
            request.getNewPassword()
        );
        
        userService.changePassword(command);
        
        return ResponseEntity.noContent().build();
    }
    
    @DeleteMapping("/{userId}")
    @PreAuthorize("hasAuthority('USER_DELETE')")
    public ResponseEntity<Void> deleteUser(@PathVariable String userId) {
        userService.deleteUser(new DeleteUserCommand(userId));
        return ResponseEntity.noContent().build();
    }
}
```

**认证服务配置**：

```yaml
spring:
  application:
    name: platform-auth-service
  datasource:
    url: jdbc:mysql://${MYSQL_HOST:localhost}:${MYSQL_PORT:3306}/${MYSQL_DATABASE:auth_db}?useSSL=false&serverTimezone=UTC
    username: ${MYSQL_USERNAME:root}
    password: ${MYSQL_PASSWORD:password}
    driver-class-name: com.mysql.cj.jdbc.Driver
  redis:
    host: ${REDIS_HOST:localhost}
    port: ${REDIS_PORT:6379}
    password: ${REDIS_PASSWORD:}
  jpa:
    hibernate:
      ddl-auto: validate
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MySQL8Dialect
    open-in-view: false

# JWT配置
jwt:
  secret: ${JWT_SECRET:defaultSecretKeyForDevelopmentOnly}
  access-token-validity-seconds: 3600
  refresh-token-validity-seconds: 86400

server:
  port: 9000

# 安全配置
security:
  allowed-origins: ${ALLOWED_ORIGINS:http://localhost:3000}
  require-ssl: ${REQUIRE_SSL:false}
  authentication:
    provider:
      username-password:
        enabled: true
      social:
        enabled: true
        providers:
          - name: google
            enabled: ${SOCIAL_GOOGLE_ENABLED:false}
          - name: facebook
            enabled: ${SOCIAL_FACEBOOK_ENABLED:false}
      mfa:
        enabled: ${MFA_ENABLED:false}
        types:
          - name: sms
            enabled: ${MFA_SMS_ENABLED:false}
          - name: email
            enabled: ${MFA_EMAIL_ENABLED:false}
          - name: authenticator
            enabled: ${MFA_AUTHENTICATOR_ENABLED:false}
```