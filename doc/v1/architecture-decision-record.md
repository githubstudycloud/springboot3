# 架构决策记录 (ADR)

## ADR-001: JDK升级与模块解耦策略

**状态**：已提议  
**日期**：2025-04-26  
**决策者**：架构团队  

### 背景

当前平台基于JDK 17构建，随着JDK 21的广泛应用和JDK 24的即将发布，平台需要进行技术栈升级以获得性能提升和新特性支持。同时，现有模块间存在较强耦合，特别是与技术框架的耦合度过高，不利于未来的持续升级和维护。

### 决策动机

1. 利用JDK 21的虚拟线程和其他新特性提升系统性能
2. 为未来升级到JDK 24做好准备
3. 优化模块结构，降低耦合度
4. 提升系统可维护性和可扩展性
5. 统一网关和限流设计，提高系统整体一致性

### 方案

#### JDK升级策略

**决策**：采用双阶段升级策略，先升级到JDK 21 LTS，同时设计兼容层为JDK 24做准备。

**理由**：
- JDK 21是长期支持版本，更稳定可靠
- 虚拟线程特性可显著提高系统并发性能
- 设计良好的抽象层可以简化未来的JDK 24升级

**替代方案**：
1. 直接等待JDK 24发布后再升级：风险较高，错失当前性能优化机会
2. 仅升级到JDK 21不考虑后续兼容：可能导致技术债务累积
3. 保持JDK 17不变：无法享受新版JDK带来的性能提升和新特性

#### 模块解耦策略

**决策**：采用六边形架构(Hexagonal Architecture)重构核心模块，实现业务逻辑与技术框架的解耦。

**理由**：
- 业务核心与技术实现分离，提高可测试性
- 技术组件可以独立升级或替换
- 适配器模式使外部依赖变得可插拔
- 领域模型不依赖于框架，减少技术栈变更影响

**替代方案**：
1. 传统三层架构：技术与业务耦合度高，不易于框架升级
2. 洋葱架构：实现复杂度较高，过渡成本大
3. 微内核架构：不适合所有模块的特性

#### 网关与注册中心整合

**决策**：保留Nacos作为配置中心和服务发现核心，增强网关的流量管理能力，实现全局一致的限流策略。

**理由**：
- 减少冗余组件，降低部署复杂度
- 统一配置管理，提高可维护性
- 实现全局一致的限流策略
- 简化运维工作

**替代方案**：
1. 完全独立的网关和注册中心：配置分散，管理复杂
2. 使用Service Mesh替代：成本高，学习曲线陡峭
3. 自研网关替代方案：开发成本高，不必要的重复造轮子

### 影响

#### 架构影响

1. 所有模块将遵循六边形架构设计
2. 领域模型与技术实现严格分离
3. API设计将更加清晰一致
4. 测试策略将更加聚焦于业务逻辑

#### 开发影响

1. 开发团队需要学习新的架构模式
2. 需要设计和实现适配器层
3. 单元测试将更容易实现
4. 新功能开发效率可能在初期下降，但长期会提高

#### 性能影响

1. 虚拟线程将显著提高并发性能
2. 架构分层可能带来轻微性能开销
3. 网关整合可以减少网络跳转
4. 全局限流可以提高系统稳定性

### 采用影响

采用此决策将导致平台重构，涉及以下工作：

1. JDK 21环境搭建和兼容性测试
2. 核心模块的六边形架构改造
3. 适配器层设计与实现
4. 全局限流系统设计与部署
5. 网关与注册中心功能整合
6. 全面的性能测试与优化

### 风险与缓解

| 风险 | 影响 | 可能性 | 缓解措施 |
|-----|-----|-------|---------|
| JDK兼容性问题 | 高 | 中 | 详细兼容性测试，准备替代方案 |
| 架构重构引入新问题 | 高 | 中 | 渐进式改造，保持原有行为 |
| 开发团队适应新架构困难 | 中 | 高 | 提前培训，编写详细文档 |
| 性能退化 | 高 | 低 | 设立性能基准，持续监控 |
| 重构过程影响业务 | 高 | 中 | 模块化改造，不影响现有功能 |

## ADR-002: 模块职责边界明确化

**状态**：已提议  
**日期**：2025-04-26  
**决策者**：架构团队  

### 背景

现有平台模块职责边界不够清晰，导致功能重叠、代码重复，以及难以理解的依赖关系。特别是数据采集、处理、监控和业务展示等功能的边界模糊，造成开发和维护困难。

### 决策动机

1. 明确各模块的核心职责，减少功能重叠
2. 优化依赖关系，降低模块间耦合
3. 简化系统理解难度，提高开发效率
4. 促进专业化开发，提高代码质量
5. 支持未来功能扩展，提高可维护性

### 方案

#### 核心模块职责定义

**决策**：明确各核心模块的职责边界，实现"高内聚、低耦合"的模块化设计：

1. **platform-collect**：专注于外源数据采集，负责从各类外部数据源抽取数据
2. **platform-fluxcore**：负责数据处理和转换，将外源数据处理为内源数据
3. **platform-common**：提供各模块共用的工具类和抽象，不包含业务逻辑
4. **platform-buss-dashboard**：业务数据展示和分析，对外提供业务API
5. **platform-monitor-dashboard**：系统监控和运维管理功能
6. **platform-gateway**：统一API入口和流量管理
7. **platform-scheduler系列**：分布式任务调度和执行

**理由**：
- 职责单一原则使各模块更易于理解和维护
- 明确的模块边界减少不必要的依赖
- 专注的职责范围有助于实现深度优化
- 符合领域驱动设计中的界限上下文概念

**替代方案**：
1. 按功能分层而非领域分割：会导致业务逻辑分散，理解困难
2. 大型整合式模块：难以维护和扩展
3. 过度细分模块：增加集成复杂性和运维负担

#### 模块间通信机制

**决策**：采用多样化的模块间通信策略，根据场景选择合适的通信方式：

1. **同步通信**：使用REST API或gRPC进行直接调用，适用于实时性要求高的场景
2. **异步通信**：使用消息队列（Kafka/RocketMQ）实现松耦合的事件驱动架构
3. **数据共享**：通过数据库或缓存实现数据共享，但严格控制共享范围
4. **服务网格**：重要服务间通信采用服务网格提供高级流量管理

**理由**：
- 不同场景需要不同的通信策略，不应强制使用单一方式
- 同步通信适合强一致性要求的场景
- 异步通信提高系统弹性和可扩展性
- 服务网格简化复杂微服务的管理

**替代方案**：
1. 纯REST架构：不适合高性能和异步场景
2. 纯消息驱动：实时性受限，调试困难
3. 中央数据库共享：造成紧耦合，不利于扩展

### 影响

#### 技术影响

1. 需要明确定义模块间的接口契约
2. 需要设计和维护API版本控制策略
3. 需要建立消息模式和事件标准
4. 跨模块追踪和监控变得更加重要

#### 开发流程影响

1. 需要更严格的模块级代码审查
2. 模块责任人角色的建立
3. 接口变更需要更严格的评审流程
4. 鼓励模块内部封装和信息隐藏

### 采用影响

采用此决策将导致：

1. 业务代码的重组和重构
2. 模块间依赖关系的梳理和调整
3. 模块内聚性提高，避免全局变更
4. 开发团队可能需要按照模块重组

### 风险与缓解

| 风险 | 影响 | 可能性 | 缓解措施 |
|-----|-----|-------|---------|
| 模块边界划分不合理 | 高 | 中 | 结合领域驱动设计，持续优化边界 |
| 接口变更影响面广 | 中 | 高 | 严格的接口版本控制和兼容策略 |
| 过度模块化导致性能问题 | 中 | 低 | 性能关键路径特殊处理 |
| 团队协作困难 | 中 | 中 | 建立跨团队协作机制和共享文档 |

## ADR-003: 数据处理架构优化

**状态**：已提议  
**日期**：2025-04-26  
**决策者**：架构团队  

### 背景

当前系统的数据处理架构主要面向批处理设计，缺乏对实时流处理的良好支持。随着业务对实时数据分析需求的增长，需要优化数据处理架构以支持更多样化的数据处理模式。同时，现有架构中外源数据采集和处理的边界不够清晰，导致职责混乱。

### 决策动机

1. 明确区分外源数据采集和数据处理职责
2. 增强对实时数据流处理的支持
3. 提供统一的数据处理抽象，简化开发
4. 提高数据处理性能和可扩展性
5. 支持更灵活的数据处理管道配置

### 方案

#### 数据处理架构重构

**决策**：采用基于管道(Pipeline)的数据处理架构，将数据采集与处理明确分离：

1. **platform-collect** 负责数据采集，提供统一的数据源抽象
2. **platform-fluxcore** 负责数据处理，提供数据转换和加工能力
3. 设计通用的数据处理接口，支持批处理和流处理两种模式
4. 实现插件式数据处理组件，支持灵活扩展

**数据流模型**：
```
外部数据源 → platform-collect(采集) → 原始数据 → platform-fluxcore(处理) → 内源数据 → 存储/分析/展示
```

**理由**：
- 清晰的职责分离提高模块内聚性
- 管道模式便于构建复杂的数据处理逻辑
- 插件化设计支持灵活扩展
- 统一抽象简化开发复杂度

**替代方案**：
1. ETL工具集成：缺乏深度定制能力，不易与系统集成
2. 大数据处理框架直接集成：增加系统复杂度和运维成本
3. 保持现状，混合职责：维护困难，扩展受限

#### 数据处理接口设计

**决策**：设计统一的数据处理接口，同时支持批处理和流处理：

```java
// 核心处理器接口
public interface DataProcessor<I, O> {
    // 批处理接口
    List<O> processBatch(List<I> inputs);
    
    // 流处理接口
    Flux<O> processStream(Flux<I> inputs);
    
    // 处理器元数据
    ProcessorMetadata getMetadata();
}

// 处理管道接口
public interface ProcessingPipeline<I, O> {
    // 添加处理器
    <T> ProcessingPipeline<I, O> addProcessor(DataProcessor<?, T> processor);
    
    // 执行管道 - 批处理模式
    List<O> execute(List<I> inputs);
    
    // 执行管道 - 流处理模式
    Flux<O> executeStream(Publisher<I> inputStream);
}
```

**理由**：
- 统一接口简化开发和使用
- 同时支持批处理和流处理满足不同场景
- 管道模式支持灵活组合处理器
- 元数据支持自描述和动态配置

**替代方案**：
1. 仅支持批处理：无法满足实时处理需求
2. 仅支持流处理：简单场景过度复杂化
3. 完全分离的批处理和流处理API：代码重复，维护困难

### 影响

#### 技术影响

1. 需要重构现有数据处理逻辑
2. 需要设计数据流监控和管理机制
3. 数据处理性能和资源使用需要优化
4. 需要考虑数据一致性和事务性

#### 开发影响

1. 开发人员需要学习新的数据处理接口
2. 需要迁移现有的数据处理逻辑
3. 测试策略需要同时覆盖批处理和流处理
4. 文档和示例需要全面更新

### 采用影响

采用此决策将导致：

1. 数据处理相关代码的重构
2. 数据流监控和管理工具的开发
3. 可能需要引入新的技术组件支持流处理
4. 性能测试和调优工作量增加

### 风险与缓解

| 风险 | 影响 | 可能性 | 缓解措施 |
|-----|-----|-------|---------|
| 接口设计不足以覆盖所有场景 | 高 | 中 | 先覆盖核心场景，保留扩展性 |
| 流处理性能瓶颈 | 高 | 中 | 性能测试驱动优化，设置监控告警 |
| 数据一致性难以保证 | 中 | 高 | 明确一致性等级，提供事务支持 |
| 学习曲线陡峭 | 中 | 中 | 详细文档和示例，培训支持 |

## ADR-004: 全局限流与流量控制

**状态**：已提议  
**日期**：2025-04-26  
**决策者**：架构团队  

### 背景

当前系统缺乏统一的限流和流量控制机制，各服务自行实现限流逻辑，导致策略不一致、配置分散、管理困难。随着业务规模增长，系统需要更强大的流量管理能力，保障系统稳定性和响应能力。

### 决策动机

1. 提供全局一致的限流策略和配置
2. 实现细粒度的流量控制能力
3. 支持多种限流算法和策略
4. 实现限流策略的动态调整
5. 提供限流监控和分析能力

### 方案

#### 多层次限流架构

**决策**：采用多层次限流架构，在不同层次实现限流控制：

1. **网关层**：实现全局入口限流，基于API路径、客户端标识、用户身份等维度
2. **服务层**：实现服务实例级限流，防止单一服务过载
3. **方法层**：实现关键方法级限流，保护核心资源

**技术实现**：
- 网关层：基于Spring Cloud Gateway + Redis实现分布式限流
- 服务层：基于Resilience4j实现服务限流
- 方法层：基于AOP和注解实现方法级限流

**理由**：
- 多层次防护提供更完整的系统保护
- 分布式限流解决集群环境下的限流同步问题
- 配置集中管理简化运维和调整
- 灵活的策略支持不同业务场景

**替代方案**：
1. 仅网关层限流：无法应对服务内部热点问题
2. 仅服务层限流：无法防止流量洪峰到达服务
3. 第三方限流服务：增加依赖，运维复杂

#### 限流策略与配置

**决策**：实现统一的限流策略配置和管理：

1. 支持多种限流算法：固定窗口、滑动窗口、令牌桶、漏桶等
2. 支持多维度限流：IP、用户、接口、业务标识等
3. 限流规则集中存储在配置中心，支持动态更新
4. 提供统一的管理界面进行策略配置和监控

**配置示例**：
```yaml
limit:
  global:
    qps: 10000
    algorithm: token-bucket
    burst-capacity: 1000
  
  services:
    user-service:
      qps: 2000
      algorithm: sliding-window
      window-size: 10s
      
      endpoints:
        "/api/v1/users":
          methods: [POST]
          qps: 100
          algorithm: fixed-window
          dimension: IP
          response:
            code: 429
            message: "请求过于频繁，请稍后再试"
```

**理由**：
- 集中配置便于管理和审计
- 多种算法适应不同场景需求
- 细粒度配置支持精确控制
- 动态更新无需重启服务

**替代方案**：
1. 硬编码限流规则：缺乏灵活性，调整困难
2. 服务自治限流配置：分散管理，策略不一致
3. 仅支持单一限流算法：无法满足多样化需求

### 影响

#### 技术影响

1. 需要实现分布式限流组件
2. 需要设计限流规则的存储和同步机制
3. 服务调用需要考虑限流响应处理
4. 监控系统需要集成限流指标

#### 开发影响

1. 开发人员需要了解限流策略和配置方式
2. 服务代码可能需要添加限流注解
3. 测试需要覆盖限流场景
4. 异常处理需要优雅应对限流情况

### 采用影响

采用此决策将导致：

1. 限流组件的开发和部署
2. 限流配置管理界面的开发
3. 现有服务调用可能需要增加重试和降级逻辑
4. 监控和告警系统需要支持限流事件

### 风险与缓解

| 风险 | 影响 | 可能性 | 缓解措施 |
|-----|-----|-------|---------|
| 限流规则配置不当导致可用性降低 | 高 | 中 | 灰度发布限流规则，监控与快速回滚 |
| 分布式限流性能瓶颈 | 高 | 中 | 性能测试与优化，本地缓存支持 |
| 限流生效延迟问题 | 中 | 中 | 双重检查机制，本地限流兜底 |
| 用户体验下降 | 中 | 高 | 优化限流响应，提供友好提示 |

## ADR-005: 前端技术栈升级到Vue 3

**状态**：已提议  
**日期**：2025-04-26  
**决策者**：架构团队  

### 背景

当前系统前端基于Vue 2.x构建，随着Vue 3的成熟和生态完善，以及TypeScript的广泛应用，需要对前端技术栈进行升级，以获得更好的性能、开发体验和类型安全。

### 决策动机

1. 利用Vue 3的性能优化和新特性
2. 采用TypeScript增强代码类型安全
3. 使用Composition API优化组件逻辑组织
4. 采用现代化构建工具提升开发效率
5. 解决Vue 2即将结束维护的风险

### 方案

#### 前端技术栈升级

**决策**：将前端技术栈升级至Vue 3 + TypeScript + Vite：

1. 核心框架：Vue 3.3+
2. 类型系统：TypeScript 5.0+
3. 构建工具：Vite
4. 状态管理：Pinia
5. 路由管理：Vue Router 4
6. UI组件库：Element Plus / Naive UI

**迁移策略**：
- 先针对独立度高的小型模块进行试点迁移
- 采用渐进式迁移策略，保证业务连续性
- 建立混合模式支持，允许Vue 2和Vue 3组件共存
- 提取公共组件库，优先进行升级

**理由**：
- Vue 3提供更好的性能和开发体验
- Composition API优化逻辑复用和组织
- TypeScript增强代码可维护性和可靠性
- Vite提供更快的开发和构建体验
- Pinia提供更简洁的状态管理方案

**替代方案**：
1. 保持Vue 2：维护风险增加，错失新特性
2. 迁移到React：学习成本高，重写工作量大
3. 迁移到Angular：架构差异大，不符合团队技术栈

#### 组件架构重构

**决策**：采用基于Composition API的组件设计模式：

1. 使用`<script setup>`语法简化组件编写
2. 逻辑关注点分离，将复杂逻辑提取为组合式函数
3. 采用TypeScript接口定义组件Props和事件
4. 统一状态管理，使用Pinia替代Vuex

**代码示例**：
```vue
<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useUserStore } from '@/stores/user'
import type { User } from '@/types'
import { useApi } from '@/composables/useApi'

// 状态和API
const userStore = useUserStore()
const { get } = useApi()
const users = ref<User[]>([])
const loading = ref(false)

// 方法
const fetchUsers = async () => {
  loading.value = true
  try {
    users.value = await get<User[]>('/api/users')
    userStore.setLastFetchTime(new Date())
  } catch (error) {
    console.error('Failed to fetch users:', error)
  } finally {
    loading.value = false
  }
}

// 生命周期
onMounted(fetchUsers)
</script>

<template>
  <div class="user-list">
    <loading-indicator v-if="loading" />
    <user-card v-else v-for="user in users" :key="user.id" :user="user" />
  </div>
</template>
```

**理由**：
- Composition API提供更好的逻辑复用机制
- 类型安全减少运行时错误
- 关注点分离提高代码可维护性
- 更简洁的组件编写方式提高开发效率

**替代方案**：
1. 继续使用Options API：逻辑组织不够灵活
2. 混合使用不同API风格：增加理解和维护成本
3. 自定义组合逻辑：缺乏框架级支持，一致性难保证

### 影响

#### 技术影响

1. 需要更新构建和开发工具链
2. 需要调整UI组件库依赖
3. TypeScript配置和类型定义工作
4. 浏览器兼容性要求可能变化

#### 开发影响

1. 开发团队需要学习Vue 3和Composition API
2. 需要建立新的前端开发规范
3. 组件库需要升级或替换
4. 测试用例需要调整和增强

### 采用影响

采用此决策将导致：

1. 前端代码的渐进式重构
2. 开发工具链的升级
3. 组件库的升级或替换
4. 新的状态管理方案实施

### 风险与缓解

| 风险 | 影响 | 可能性 | 缓解措施 |
|-----|-----|-------|---------|
| 迁移过程中引入新bug | 高 | 中 | 完善的测试覆盖，渐进式迁移 |
| 学习曲线导致生产力暂时下降 | 中 | 高 | 预先培训，编写详细指南 |
| UI组件库兼容性问题 | 中 | 中 | 提前评估，必要时提供兼容层 |
| 构建和部署问题 | 中 | 低 | 搭建独立的CI/CD流程验证 |
